<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=2">
<meta name="theme-color" content="#222">
<meta name="generator" content="Hexo 7.3.0">
<meta name="google-site-verification" content="WoeYixr9--6ikwIZxHiYjVfhk2UpqldMqWnPGdyKfBw" />
  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png">
  <link rel="mask-icon" href="/images/logo.svg" color="#222">

<link rel="stylesheet" href="/css/main.css">


<link rel="stylesheet" href="/lib/font-awesome/css/all.min.css">

<script id="hexo-configurations">
    var NexT = window.NexT || {};
    var CONFIG = {"hostname":"frontendthink.com","root":"/","scheme":"Gemini","version":"7.8.0","exturl":false,"sidebar":{"position":"left","display":"post","padding":18,"offset":12,"onmobile":false},"copycode":{"enable":false,"show_result":false,"style":null},"back2top":{"enable":true,"sidebar":false,"scrollpercent":false},"bookmark":{"enable":false,"color":"#222","save":"auto"},"fancybox":false,"mediumzoom":false,"lazyload":false,"pangu":false,"comments":{"style":"tabs","active":null,"storage":true,"lazyload":false,"nav":null},"algolia":{"hits":{"per_page":10},"labels":{"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}},"localsearch":{"enable":true,"trigger":"auto","top_n_per_article":1,"unescape":false,"preload":false},"motion":{"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}},"path":"search.xml"};
  </script>

  <meta name="description" content="青春都一餉，忍把浮名換了代碼輕狂。">
<meta property="og:type" content="website">
<meta property="og:title" content="Philip">
<meta property="og:url" content="https://frontendthink.com/index.html">
<meta property="og:site_name" content="Philip">
<meta property="og:description" content="青春都一餉，忍把浮名換了代碼輕狂。">
<meta property="og:locale" content="en_US">
<meta property="article:author" content="Philip Zhang">
<meta name="twitter:card" content="summary">

<link rel="canonical" href="https://frontendthink.com/">


<script id="page-configurations">
  // https://hexo.io/docs/variables.html
  CONFIG.page = {
    sidebar: "",
    isHome : true,
    isPost : false,
    lang   : 'en'
  };
</script>

  <title>Philip</title>
  






  <noscript>
  <style>
  .use-motion .brand,
  .use-motion .menu-item,
  .sidebar-inner,
  .use-motion .post-block,
  .use-motion .pagination,
  .use-motion .comments,
  .use-motion .post-header,
  .use-motion .post-body,
  .use-motion .collection-header { opacity: initial; }

  .use-motion .site-title,
  .use-motion .site-subtitle {
    opacity: initial;
    top: initial;
  }

  .use-motion .logo-line-before i { left: initial; }
  .use-motion .logo-line-after i { right: initial; }
  </style>
</noscript>

</head>

<body itemscope itemtype="http://schema.org/WebPage">
  <div class="container use-motion">
    <div class="headband"></div>

    <header class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-container">
  <div class="site-nav-toggle">
    <div class="toggle" aria-label="Toggle navigation bar">
      <span class="toggle-line toggle-line-first"></span>
      <span class="toggle-line toggle-line-middle"></span>
      <span class="toggle-line toggle-line-last"></span>
    </div>
  </div>

  <div class="site-meta">

    <a href="/" class="brand" rel="start">
      <span class="logo-line-before"><i></i></span>
      <h1 class="site-title">Philip</h1>
      <span class="logo-line-after"><i></i></span>
    </a>
      <p class="site-subtitle" itemprop="description">Philip's blog</p>
  </div>

  <div class="site-nav-right">
    <div class="toggle popup-trigger">
        <i class="fa fa-search fa-fw fa-lg"></i>
    </div>
  </div>
</div>




<nav class="site-nav">
  <ul id="menu" class="main-menu menu">
        <li class="menu-item menu-item-home">

    <a href="/" rel="section"><i class="fa fa-home fa-fw"></i>Home</a>

  </li>
        <li class="menu-item menu-item-tags">

    <a href="/tags/" rel="section"><i class="fa fa-tags fa-fw"></i>Tags</a>

  </li>
        <li class="menu-item menu-item-categories">

    <a href="/categories/" rel="section"><i class="fa fa-th fa-fw"></i>Categories</a>

  </li>
        <li class="menu-item menu-item-archives">

    <a href="/archives/" rel="section"><i class="fa fa-archive fa-fw"></i>Archives</a>

  </li>
      <li class="menu-item menu-item-search">
        <a role="button" class="popup-trigger"><i class="fa fa-search fa-fw"></i>Search
        </a>
      </li>
  </ul>
</nav>



  <div class="search-pop-overlay">
    <div class="popup search-popup">
        <div class="search-header">
  <span class="search-icon">
    <i class="fa fa-search"></i>
  </span>
  <div class="search-input-container">
    <input autocomplete="off" autocapitalize="off"
           placeholder="Searching..." spellcheck="false"
           type="search" class="search-input">
  </div>
  <span class="popup-btn-close">
    <i class="fa fa-times-circle"></i>
  </span>
</div>
<div id="search-result">
  <div id="no-result">
    <i class="fa fa-spinner fa-pulse fa-5x fa-fw"></i>
  </div>
</div>

    </div>
  </div>

</div>
    </header>

    
  <div class="back-to-top">
    <i class="fa fa-arrow-up"></i>
    <span>0%</span>
  </div>


    <main class="main">
      <div class="main-inner">
        <div class="content-wrap">
          

          <div class="content index posts-expand">
            
      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="en">
    <link itemprop="mainEntityOfPage" href="https://frontendthink.com/2025/07/10/typescript-type-predicate/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="Philip Zhang">
      <meta itemprop="description" content="青春都一餉，忍把浮名換了代碼輕狂。">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Philip">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2025/07/10/typescript-type-predicate/" class="post-title-link" itemprop="url">typescript-type-predicate</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>
              

              <time title="Created: 2025-07-10 19:15:44 / Modified: 22:48:29" itemprop="dateCreated datePublished" datetime="2025-07-10T19:15:44+08:00">2025-07-10</time>
            </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">In</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/typescript/" itemprop="url" rel="index"><span itemprop="name">typescript</span></a>
                </span>
            </span>

          <br>
            <span class="post-meta-item" title="Symbols count in article">
              <span class="post-meta-item-icon">
                <i class="far fa-file-word"></i>
              </span>
                <span class="post-meta-item-text">Symbols count in article: </span>
              <span>660</span>
            </span>
            <span class="post-meta-item" title="Reading time">
              <span class="post-meta-item-icon">
                <i class="far fa-clock"></i>
              </span>
                <span class="post-meta-item-text">Reading time &asymp;</span>
              <span>2 mins.</span>
            </span>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h2 id="介绍"><a href="#介绍" class="headerlink" title="介绍"></a>介绍</h2><p>各位老铁上午好，昨天我们学习了TypeScript中的类型断言(as操作符)，今天我们来学习TypeScript中的类型谓词（Type Predicate）(is操作符)。</p>
<p>为什么需要类型谓词呢？我们先看一个例子，假设我们要写一个函数，判断一个变量是否为字符串类型。</p>
<figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">isString</span>(<span class="params"><span class="attr">value</span>: <span class="built_in">unknown</span></span>): <span class="built_in">boolean</span> &#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">typeof</span> value === <span class="string">&#x27;string&#x27;</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>调用这个函数</p>
<figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">example</span>(<span class="params"><span class="attr">foo</span>: <span class="built_in">any</span></span>) &#123;</span><br><span class="line">  <span class="keyword">if</span> (<span class="title function_">isString</span>(foo)) &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(foo.<span class="title function_">toUpperCase</span>()); <span class="comment">// 这里会报错，因为foo的类型仍然是any</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="title function_">example</span>(<span class="string">&quot;hello&quot;</span>); <span class="comment">// 输出 &quot;HELLO&quot;</span></span><br><span class="line"><span class="title function_">example</span>(<span class="number">123</span>); <span class="comment">// 不会输出任何内容</span></span><br></pre></td></tr></table></figure>

<p>看起来一切正常，但是假如我们疏忽了，不小心在<code>example</code>中调用了一个不属于字符串的方法，比如<code>toFixed</code>，TypeScript会报错，因为字符串上没有<code>toFixed</code>方法。</p>
<figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">example</span>(<span class="params"><span class="attr">foo</span>: <span class="built_in">any</span></span>) &#123;</span><br><span class="line">  <span class="keyword">if</span> (<span class="title function_">isString</span>(foo)) &#123; <span class="comment">// foo的类型是any，通过检查</span></span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(foo.<span class="title function_">toFixed</span>(<span class="number">2</span>)); <span class="comment">// 编译时没有问题</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="title function_">example</span>(<span class="string">&quot;hello&quot;</span>); <span class="comment">// 运行时报错，因为字符串上没有toFixed方法</span></span><br></pre></td></tr></table></figure>

<p>在上面的代码中，虽然满足了<code>isString()</code>的判断，但是在编译期间，foo还是它本来的类型，typescript无法在编译期检查到错误。</p>
<p>但是，如果我们加上类型谓词，IDE就会提示字符串上没有<code>toFixed</code>方法。也就是说，类型谓词可以在编译时就杜绝类型错误，这就是它核心的功能。</p>
<figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">isString</span>(<span class="params"><span class="attr">value</span>: <span class="built_in">unknown</span></span>): value is <span class="built_in">string</span> &#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">typeof</span> value === <span class="string">&#x27;string&#x27;</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>上面的代码中，typescript在编译期就会将value的类型窄化为<code>string</code>，如果调用的方法不属于<code>string</code>类型，IDE会提示错误。</p>
<figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">example</span>(<span class="params"><span class="attr">foo</span>: <span class="built_in">any</span></span>) &#123;</span><br><span class="line">  <span class="keyword">if</span> (<span class="title function_">isString</span>(foo)) &#123;</span><br><span class="line">    <span class="comment">// TS2551: Property &#x27;toFixed&#x27; does not exist on type &#x27;string&#x27;.</span></span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(foo.<span class="title function_">toFixed</span>(<span class="number">2</span>)); <span class="comment">// 编译期报错</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="类型谓词的语法规则"><a href="#类型谓词的语法规则" class="headerlink" title="类型谓词的语法规则"></a>类型谓词的语法规则</h2><p>类型谓词要写在函数的返回值上，形式为：<code>value is Type</code>，其中<code>value</code>是函数的参数，<code>Type</code>是要判断的类型，比如一个判断<code>number</code>类型的函数可以这样写：</p>
<figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">isNumber</span>(<span class="params"><span class="attr">value</span>: <span class="built_in">unknown</span></span>): value is <span class="built_in">number</span> &#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">typeof</span> value === <span class="string">&#x27;number&#x27;</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="类型谓词的作用范围"><a href="#类型谓词的作用范围" class="headerlink" title="类型谓词的作用范围"></a>类型谓词的作用范围</h2><p>需要注意的是，类型谓词只在<code>isString</code>函数的作用域内有效。也就是说，只有在<code>isString</code>函数返回<code>true</code>的情况下，TypeScript才会将传入的参数类型窄化为<code>string</code>。</p>
<figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">example</span>(<span class="params"><span class="attr">foo</span>: <span class="built_in">any</span></span>) &#123;</span><br><span class="line">  <span class="keyword">if</span> (<span class="title function_">isString</span>(foo)) &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(foo.<span class="title function_">toFixed</span>()); <span class="comment">// 编译期报错，因为foo的类型被窄化为string</span></span><br><span class="line">  &#125; </span><br><span class="line"></span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(foo.<span class="title function_">toFixed</span>()); <span class="comment">// 运行时报错，因为foo的类型仍然是any</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="title function_">example</span>(<span class="string">&quot;hello&quot;</span>);</span><br></pre></td></tr></table></figure>

<p>好了，今天就到这里了，我们明天见。</p>
<blockquote>
<p>今天又买了一把新弹弓：锁凤十代，握感舒适，重量适中。理查德说这个弓可以留着，我再试两天再说。</p>
</blockquote>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="en">
    <link itemprop="mainEntityOfPage" href="https://frontendthink.com/2025/07/09/typescript-type-assertion-1/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="Philip Zhang">
      <meta itemprop="description" content="青春都一餉，忍把浮名換了代碼輕狂。">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Philip">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2025/07/09/typescript-type-assertion-1/" class="post-title-link" itemprop="url">typescript-type-assertion</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>

              <time title="Created: 2025-07-09 19:42:19" itemprop="dateCreated datePublished" datetime="2025-07-09T19:42:19+08:00">2025-07-09</time>
            </span>

          <br>
            <span class="post-meta-item" title="Symbols count in article">
              <span class="post-meta-item-icon">
                <i class="far fa-file-word"></i>
              </span>
                <span class="post-meta-item-text">Symbols count in article: </span>
              <span>0</span>
            </span>
            <span class="post-meta-item" title="Reading time">
              <span class="post-meta-item-icon">
                <i class="far fa-clock"></i>
              </span>
                <span class="post-meta-item-text">Reading time &asymp;</span>
              <span>1 mins.</span>
            </span>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          
      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="en">
    <link itemprop="mainEntityOfPage" href="https://frontendthink.com/2025/07/08/typescript-pick-optional-types/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="Philip Zhang">
      <meta itemprop="description" content="青春都一餉，忍把浮名換了代碼輕狂。">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Philip">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2025/07/08/typescript-pick-optional-types/" class="post-title-link" itemprop="url">typescript-pick-optional-types</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>

              <time title="Created: 2025-07-08 23:20:53" itemprop="dateCreated datePublished" datetime="2025-07-08T23:20:53+08:00">2025-07-08</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">Edited on</span>
                <time title="Modified: 2025-07-09 07:58:45" itemprop="dateModified" datetime="2025-07-09T07:58:45+08:00">2025-07-09</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">In</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/typescript/" itemprop="url" rel="index"><span itemprop="name">typescript</span></a>
                </span>
            </span>

          <br>
            <span class="post-meta-item" title="Symbols count in article">
              <span class="post-meta-item-icon">
                <i class="far fa-file-word"></i>
              </span>
                <span class="post-meta-item-text">Symbols count in article: </span>
              <span>1.7k</span>
            </span>
            <span class="post-meta-item" title="Reading time">
              <span class="post-meta-item-icon">
                <i class="far fa-clock"></i>
              </span>
                <span class="post-meta-item-text">Reading time &asymp;</span>
              <span>6 mins.</span>
            </span>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h2 id="什么是可选属性？"><a href="#什么是可选属性？" class="headerlink" title="什么是可选属性？"></a>什么是可选属性？</h2><p>今天我们来看一下如何从一个 TypeScript 类型中提取可选属性。那么什么是可选属性呢?<br>可选属性是指在类型定义中使用问号（<code>?</code>）标记的属性，这些属性在对象中可以存在也可以不存在。</p>
<p>以下面的<code>User</code>类型为例：其中id和name是必需的属性，而age和email是可选的属性。</p>
<figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">interface</span> <span class="title class_">User</span> &#123;</span><br><span class="line">  <span class="attr">id</span>: <span class="built_in">number</span>;</span><br><span class="line">  <span class="attr">name</span>: <span class="built_in">string</span>;</span><br><span class="line">  <span class="attr">age</span>?: <span class="built_in">number</span>; <span class="comment">// 可选属性</span></span><br><span class="line">  <span class="attr">email</span>?: <span class="built_in">string</span>; <span class="comment">// 可选属性</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>对于必须属性，我们在定义变量的时候必须提供这些属性的值。</p>
<p>下面这个变量定义是正确的，因为id和name这两个必须属性都出现了。</p>
<figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="attr">user1</span>: <span class="title class_">User</span> = &#123;</span><br><span class="line">  <span class="attr">id</span>: <span class="number">1</span>,</span><br><span class="line">  <span class="attr">name</span>: <span class="string">&#x27;Alice&#x27;</span>,</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>下面这个变量定义则是错误的，因为缺少了id属性。</p>
<figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="attr">user2</span>: <span class="title class_">User</span> = &#123;</span><br><span class="line">  <span class="attr">name</span>: <span class="string">&#x27;Philip&#x27;</span>,</span><br><span class="line">  <span class="attr">age</span>: <span class="number">18</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>TypeScript对于上面这个类型定义会给出如下错误：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">TS2741: Property &#x27;id&#x27; is missing in type &#x27;&#123; name: string; &#125;&#x27; but required in type &#x27;User&#x27;.</span><br></pre></td></tr></table></figure>

<p>对于可选属性，当它未出现在变量中时，它的值就是<code>undefined</code>（对应的类型也是<code>undefined</code>），这个特性非常重要，后面我们会用到。比如对于上面的<code>user1</code>来说，<code>user</code>.age和<code>user.email</code>的值都是<code>undefined</code>。</p>
<h2 id="可选属性的类型"><a href="#可选属性的类型" class="headerlink" title="可选属性的类型"></a>可选属性的类型</h2><p>可选属性出现时，那么它的类型就是定义的类型，比如上面的<code>age</code>属性的类型是<code>number</code>，<code>email</code>属性的类型是<code>string</code>。</p>
<p>如果可选属性未出现，那么它的类型就是<code>undefined</code>，比如上面的<code>user1</code>变量中，<code>user1.age</code>和<code>user1.email</code>的类型都是<code>undefined</code>。</p>
<p>综合下来，我们可以得出一个结论：可选属性的类型是<code>T | undefined</code>，其中<code>T</code>是可选属性的定义类型。</p>
<p>将<code>User</code>类型复制到IDE中，可以将鼠标悬停在<code>age</code>和<code>email</code>属性上，查看它们的类型。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">age 对应的类型是 number | undefined</span><br><span class="line">email 对应的类型是 string | undefined</span><br></pre></td></tr></table></figure>

<h2 id="提取可选属性"><a href="#提取可选属性" class="headerlink" title="提取可选属性"></a>提取可选属性</h2><p>可选属性介绍完毕，，现在问题来了，如何从一个类型定义中提取出所有可选属性，对应上面的<code>User</code>类型，我们需要提取出<code>age</code>和<code>email</code>这两个属性。</p>
<p>我们可以分步骤解决这个问题，每个步骤解决一个问题</p>
<h2 id="第一步：获取所有属性"><a href="#第一步：获取所有属性" class="headerlink" title="第一步：获取所有属性"></a>第一步：获取所有属性</h2><p>要提取可选属性，我们首先需要获取类型中所有的属性。TypeScript提供了内置的<code>keyof</code>操作符，可以获取一个类型的所有键（属性）。</p>
<p>假设给定的是一个类型T，那么<code>keyof T</code>将返回一个联合类型，包含T的所有属性名。</p>
<figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> <span class="title class_">UserKeys</span> = keyof <span class="title class_">User</span>; <span class="comment">// &quot;id&quot; | &quot;name&quot; | &quot;age&quot; | &quot;email&quot;</span></span><br></pre></td></tr></table></figure>
<p>假设给定的不是一个类型，而是一个变量，那么首先要用<code>typeof</code>操作符获取变量对应的的类型。再使用<code>keyof</code>获取该类型所有属性。</p>
<figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> user = &#123;</span><br><span class="line">  <span class="attr">id</span>: <span class="number">1</span>,</span><br><span class="line">  <span class="attr">name</span>: <span class="string">&#x27;Alice&#x27;</span>,</span><br><span class="line">  <span class="attr">age</span>: <span class="number">30</span>,</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> <span class="title class_">UserKeys</span> = keyof <span class="keyword">typeof</span> user; <span class="comment">// &quot;id&quot; | &quot;name&quot; | &quot;age&quot;</span></span><br></pre></td></tr></table></figure>
<p>可以看到虽然<code>user</code>变量属于<code>User</code>类型，但是两者返回的属性并不完全相同，因为<code>user</code>变量并未包含<code>email</code>属性。</p>
<h2 id="第二步：判断一个类型是否是可选的"><a href="#第二步：判断一个类型是否是可选的" class="headerlink" title="第二步：判断一个类型是否是可选的"></a>第二步：判断一个类型是否是可选的</h2><p>typescript中并没有提供内置的操作符判断一个属性是否是可选的，但是我们可以通过条件类型来实现。</p>
<p>前面说过当可选类型<code>未出现</code>时，他的值就是<code>undefined</code>(类型也是<code>undefined</code>)，所以我们可以通过判断一个属性的类型是否包含<code>undefined</code>来判断它是否是可选的。</p>
<p>下面我们来定义一个类型<code>IsOptional</code>，它接受两个参数：一个类型T和一个属性K。它将返回一个布尔值，表示属性K是否是类型T的可选属性。</p>
<p>代码大概是这个样子的</p>
<figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> <span class="title class_">IsOptional</span>&lt;T, K&gt; = <span class="literal">undefined</span> <span class="keyword">extends</span> T[K] ? <span class="literal">true</span> : <span class="literal">false</span>;</span><br></pre></td></tr></table></figure>
<p>如果K是可选的，那么T[K]的值就有可能是<code>undefined</code>，因此<code>undefined extends T[K]</code>将返回<code>true</code>，否则返回<code>false</code>。</p>
<p>举个例子：我们将T和K对应到文章开头的类型定义中，令<code>T = User</code>, 假设<code>K = age</code>，那么就有：</p>
<ul>
<li>当<code>age</code>属性存在时：<code>T[K] = number</code></li>
<li>当<code>age</code>属性不存在时：<code>T[K] = undefined</code><br>所以<code>T[K] = number | undefined</code>，因此<code>undefined extends T[K]</code>将返回<code>true</code>。</li>
</ul>
<p>假设<code>K = name</code>，因为<code>name</code>属性是必需的，所以<code>T[K] = string</code>，因此<code>undefined extends T[K]</code>将返回<code>false</code>。</p>
<p>似乎问题就要解决了，但是这里还有一个严重的问题，那就是K必须是T的属性，否则<code>T[K]</code>将会报错。所以我们还要限制一下K的值。</p>
<figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> <span class="title class_">IsOptional</span>&lt;T, K <span class="keyword">extends</span> keyof T&gt; = <span class="literal">undefined</span> <span class="keyword">extends</span> T[K] ? <span class="literal">true</span> : <span class="literal">false</span>;</span><br></pre></td></tr></table></figure>
<p><code>K extends keyof T</code>的意思是K必须是T的属性之一，这样可以避免<code>T[K]</code>报错。</p>
<h2 id="第三步：提取可选属性"><a href="#第三步：提取可选属性" class="headerlink" title="第三步：提取可选属性"></a>第三步：提取可选属性</h2><p>现在我们已经有了获取所有属性的类型<code>UserKeys</code>和判断一个属性是否是可选的类型<code>IsOptional</code>，接下来我们只需要把这两步结合起来即可：</p>
<ol>
<li>对于一个给定的类型T，我们首先获取其所有属性。</li>
<li>遍历步骤1中获取的所有属性，对于每个属性K，使用<code>IsOptional&lt;T, K&gt;</code>判断它是否是可选的。</li>
<li>如果是可选的，就将其包含在结果中，否则将其排除。</li>
</ol>
<p>代码如下：</p>
<figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> <span class="title class_">OptionalKeys</span>&lt;T&gt; = keyof &#123;</span><br><span class="line">  [K <span class="keyword">in</span> keyof T <span class="keyword">as</span> <span class="title class_">IsOptional</span>&lt;T, K&gt; <span class="keyword">extends</span> <span class="literal">true</span> ? K : <span class="built_in">never</span>]: <span class="built_in">any</span>;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>这段代码的核心部分在于<code>[K in keyof T as IsOptional&lt;T, K&gt; extends true ? K : never]</code> - 这一行代码对应了我们上面的三个步骤。</p>
<ul>
<li><code>keyof T</code> 获取所有属性。</li>
<li><code>K in keyof T</code>遍历所有属性。</li>
<li><code>as IsOptional&lt;T, K&gt; extends true ? K : never</code> 对于类型K，使用条件类型来判断属性K是否是可选的，如果是则保留K，否则将其排除（变为<code>never</code>）。</li>
</ul>
<p>但是最后为什么还有一个any呢？因为这是一个遍历操作，我们要把结果放到一个对象中，对象的key是我们提取的可选属性，对象的值就是<code>any</code>，<code>any</code>只是用来来占位的，即使使用其他类型也是一样的，比如<code>unknown</code>或者<code>void</code>都可以。</p>
<p>循环遍历完成后，我们得到一个对象如下：</p>
<figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  <span class="attr">age</span>?: <span class="built_in">any</span>;</span><br><span class="line">  <span class="attr">email</span>?: <span class="built_in">any</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>最后再使用使用<code>keyof</code>操作符获取这个对象的所有键，就得到了可选属性的联合类型：<code>&quot;age&quot; | &quot;email&quot;</code></p>
<figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">keyof &#123;</span><br><span class="line">  <span class="attr">age</span>?: <span class="built_in">any</span>;</span><br><span class="line">  <span class="attr">email</span>?: <span class="built_in">any</span>;</span><br><span class="line">&#125; <span class="comment">// &quot;age&quot; | &quot;email&quot;</span></span><br></pre></td></tr></table></figure>
<p>因此，最终的<code>OptionalKeys&lt;User&gt;</code>将返回<code>&quot;age&quot; | &quot;email&quot;</code>。</p>
<p>好了，今天就到这里了，感谢大家的支持！我们明天见。</p>
<blockquote>
<p>其实这篇文章是分两次写的，昨天晚上写了一半困得不行，遂作罢，今天早上又起来继续写。日更不能停啊。</p>
</blockquote>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="en">
    <link itemprop="mainEntityOfPage" href="https://frontendthink.com/2025/07/07/javascript-object-iterate/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="Philip Zhang">
      <meta itemprop="description" content="青春都一餉，忍把浮名換了代碼輕狂。">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Philip">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2025/07/07/javascript-object-iterate/" class="post-title-link" itemprop="url">javascript-object-iterate</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>
              

              <time title="Created: 2025-07-07 22:12:28 / Modified: 23:14:20" itemprop="dateCreated datePublished" datetime="2025-07-07T22:12:28+08:00">2025-07-07</time>
            </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">In</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/javascript/" itemprop="url" rel="index"><span itemprop="name">javascript</span></a>
                </span>
            </span>

          <br>
            <span class="post-meta-item" title="Symbols count in article">
              <span class="post-meta-item-icon">
                <i class="far fa-file-word"></i>
              </span>
                <span class="post-meta-item-text">Symbols count in article: </span>
              <span>1k</span>
            </span>
            <span class="post-meta-item" title="Reading time">
              <span class="post-meta-item-icon">
                <i class="far fa-clock"></i>
              </span>
                <span class="post-meta-item-text">Reading time &asymp;</span>
              <span>4 mins.</span>
            </span>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h2 id="JavaScript中如何遍历对象？"><a href="#JavaScript中如何遍历对象？" class="headerlink" title="JavaScript中如何遍历对象？"></a>JavaScript中如何遍历对象？</h2><p>今天来点稍微轻松的话题，如何在JavaScript中遍历对象，在平常的工作中，遍历对象是很常见的操作，javascript提供了多种方法来遍历对象的属性。这些方法各有特点，不同的场景需要使用不同的方法。</p>
<p>假设我们有一个<code>Person</code>对象，包含名字和年龄两个属性，下面看看有哪些方式可以遍历这个对象。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> person = &#123;</span><br><span class="line">  <span class="attr">name</span>: <span class="string">&#x27;Philip&#x27;</span>,</span><br><span class="line">  <span class="attr">age</span>: <span class="number">18</span>,</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h2 id="for…in"><a href="#for…in" class="headerlink" title="for…in"></a>for…in</h2><p>遍历对象最基本的方式就是使用<code>for...in</code>，这里需要注意区分和<code>for...of</code>的区别。</p>
<ul>
<li><code>for...in</code> - 遍历可枚举对象，比如<code>Object</code>。</li>
<li><code>for...of</code> - 遍历可迭代对象，比如<code>Array</code>。</li>
</ul>
<p>在以下代码中，<code>key</code>是每个属性的名字 - 对应<code>name</code>和<code>age</code>，而<code>person[key]</code>则是每个属性的值 - 对应<code>Philip</code>和<code>18</code>。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> (<span class="keyword">const</span> key <span class="keyword">in</span> person) &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(key, person[key]);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>输出如下：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">name Philip</span><br><span class="line">age 18</span><br></pre></td></tr></table></figure>
<p><code>for...in</code>是遍历对象最基本的方式，需要注意的是它不仅会遍历对象自身的属性，也会遍历原型链上的属性。假设我们在<code>Object.prototype</code>上添加一个属性，那么这个属性也会被遍历到。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="title class_">Object</span>.<span class="property"><span class="keyword">prototype</span></span>.<span class="property">customProperty</span> = <span class="string">&#x27;Hello World&#x27;</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">const</span> key <span class="keyword">in</span> person) &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(key, person[key]);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>输出如下：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">name Philip</span><br><span class="line">age 18</span><br><span class="line">customProperty Hello World</span><br></pre></td></tr></table></figure>
<p>如果你只想遍历对象自身的属性，可以使用<code>Object.hasOwnProperty</code>方法来过滤掉原型链上的属性。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> (<span class="keyword">const</span> key <span class="keyword">in</span> person) &#123;</span><br><span class="line">  <span class="keyword">if</span> (person.<span class="title function_">hasOwnProperty</span>(key)) &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(key, person[key]);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="使用for-of-Object-keys"><a href="#使用for-of-Object-keys" class="headerlink" title="使用for...of + Object.keys"></a>使用<code>for...of</code> + <code>Object.keys</code></h2><p><code>Object.keys</code>方法返回一个对象中所有可枚举属性的键名并放到一个数组里，配合<code>for...of</code>可以很方便地遍历对象的属性。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> (<span class="keyword">const</span> key <span class="keyword">of</span> <span class="title class_">Object</span>.<span class="title function_">keys</span>(person)) &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(key, person[key]);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="使用for-of-Object-values"><a href="#使用for-of-Object-values" class="headerlink" title="使用for...of + Object.values"></a>使用<code>for...of</code> + <code>Object.values</code></h2><p>如果你只关心对象的值，而不在key的话，那么可以使用<code>Object.values</code>方法，它返回一个包含对象所有可枚举属性值的数组。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> (<span class="keyword">const</span> value <span class="keyword">of</span> <span class="title class_">Object</span>.<span class="title function_">values</span>(person)) &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(value);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>输出如下：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Philip</span><br><span class="line">18</span><br></pre></td></tr></table></figure>

<h2 id="for-of-Object-entries"><a href="#for-of-Object-entries" class="headerlink" title="for...of + Object.entries"></a><code>for...of</code> + <code>Object.entries</code></h2><p>下面的方法使用<code>for...of</code>进行遍历，我们都知道<code>for..of</code>是用来遍历可迭代对象的，所以<code>Object.entries</code>返回的一定是一个可迭代对象 - 这里是一个二维数组，然后<code>[key, value]</code>是一个解构操作，负责解构内层一维数组中的值并输出。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> (<span class="keyword">const</span> [key, value] <span class="keyword">of</span> <span class="title class_">Object</span>.<span class="title function_">entries</span>(person)) &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(key, value);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><code>Object.entries(person)</code>输出如下，可以看作是一个键值对组成的二维数组。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[[name, <span class="string">&#x27;Philip&#x27;</span>], [age， <span class="number">18</span>]]</span><br></pre></td></tr></table></figure>
<p>使用<code>[key, value]</code>进行解构后正好得到两组数据：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">key = name, value = <span class="string">&#x27;Philip&#x27;</span> <span class="comment">// 第一组数据</span></span><br><span class="line">key = age, value = <span class="number">18</span> <span class="comment">// 第二组数据</span></span><br></pre></td></tr></table></figure>

<h2 id="Object-entries-forEach"><a href="#Object-entries-forEach" class="headerlink" title="Object.entries + forEach"></a><code>Object.entries</code> + <code>forEach</code></h2><p>一个更加函数式的写法是使用数组对象上的<code>forEach</code>方法。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="title class_">Object</span>.<span class="title function_">entries</span>(person).<span class="title function_">forEach</span>(<span class="function">(<span class="params">[key, value]</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(key, value);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>
<p><code>forEach</code>本质上和<code>for...of</code>并无区别，在使用链式操作时，这种方式可读性更好，比如和<code>filter</code>等方法串联调用时。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="title class_">Object</span>.<span class="title function_">entries</span>(person)</span><br><span class="line">  .<span class="title function_">filter</span>(<span class="function">(<span class="params">[key, value]</span>) =&gt;</span> key !== <span class="string">&#x27;age&#x27;</span>) <span class="comment">// 过滤掉 age 属性</span></span><br><span class="line">  .<span class="title function_">forEach</span>(<span class="function">(<span class="params">[key, value]</span>) =&gt;</span> <span class="variable language_">console</span>.<span class="title function_">log</span>(key));</span><br></pre></td></tr></table></figure>
<p>还有一点要注意，那就是<code>forEach</code>是无法中断的，比如不能使用<code>continue</code>或者<code>break</code>来中断循环，但是<code>for...in</code>和<code>for...of</code>则不受此限制。</p>
<h2 id="Reflect-ownKeys"><a href="#Reflect-ownKeys" class="headerlink" title="Reflect.ownKeys"></a>Reflect.ownKeys</h2><p>如果你的对象中有<code>Symbol</code>类型的属性，那么可以使用<code>Reflect.ownKeys</code>方法来获取所有属性的键名。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> person = &#123;</span><br><span class="line">  <span class="attr">name</span>: <span class="string">&#x27;Philip&#x27;</span>,</span><br><span class="line">  <span class="attr">age</span>: <span class="number">18</span>,</span><br><span class="line">  [<span class="title class_">Symbol</span>(<span class="string">&#x27;id&#x27;</span>)]: <span class="number">123</span>,</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="title class_">Reflect</span>.<span class="title function_">ownKeys</span>(person).<span class="title function_">forEach</span>(<span class="function"><span class="params">key</span> =&gt;</span> &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(key, person[key]);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>
<p>输出如下：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">name Philip</span><br><span class="line">age 18</span><br><span class="line">Symbol(id) 123</span><br></pre></td></tr></table></figure>
<p><code>Reflect.ownKeys</code>是遍历<code>Symbol</code>类型属性的唯一方法。</p>
<p>最后，如果你使用的是<code>TypeScript</code>，那么所有使用了索引操作的遍历方式（比如<code>person[key]</code>）都需要添加索引签名，否则<code>TypeScript</code>会报错，具体原因可以看这篇：</p>
<p>好了最后用表格总结一下：</p>
<table>
<thead>
<tr>
<th>方法</th>
<th>包含继承属性</th>
<th>包含Symbol</th>
<th>包含不可枚举属性</th>
<th>TypeScript支持</th>
</tr>
</thead>
<tbody><tr>
<td><code>for...in</code></td>
<td>✅</td>
<td>❌</td>
<td>❌</td>
<td>需要索引签名</td>
</tr>
<tr>
<td><code>Object.keys()</code></td>
<td>❌</td>
<td>❌</td>
<td>❌</td>
<td>✅</td>
</tr>
<tr>
<td><code>Object.values()</code></td>
<td>❌</td>
<td>❌</td>
<td>❌</td>
<td>✅</td>
</tr>
<tr>
<td><code>Object.entries()</code></td>
<td>❌</td>
<td>❌</td>
<td>❌</td>
<td>✅</td>
</tr>
<tr>
<td><code>Reflect.ownKeys()</code></td>
<td>❌</td>
<td>✅</td>
<td>✅</td>
<td>✅</td>
</tr>
</tbody></table>
<p>今天就到这里了，今天是我生日，感谢大家的支持，我们明天见！</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="en">
    <link itemprop="mainEntityOfPage" href="https://frontendthink.com/2025/07/06/typescript-index-signature/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="Philip Zhang">
      <meta itemprop="description" content="青春都一餉，忍把浮名換了代碼輕狂。">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Philip">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2025/07/06/typescript-index-signature/" class="post-title-link" itemprop="url">typescript-index-signature</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>
              

              <time title="Created: 2025-07-06 16:47:46 / Modified: 18:02:33" itemprop="dateCreated datePublished" datetime="2025-07-06T16:47:46+08:00">2025-07-06</time>
            </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">In</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/typescript/" itemprop="url" rel="index"><span itemprop="name">typescript</span></a>
                </span>
            </span>

          <br>
            <span class="post-meta-item" title="Symbols count in article">
              <span class="post-meta-item-icon">
                <i class="far fa-file-word"></i>
              </span>
                <span class="post-meta-item-text">Symbols count in article: </span>
              <span>745</span>
            </span>
            <span class="post-meta-item" title="Reading time">
              <span class="post-meta-item-icon">
                <i class="far fa-clock"></i>
              </span>
                <span class="post-meta-item-text">Reading time &asymp;</span>
              <span>3 mins.</span>
            </span>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h2 id="为什么我的对象无法添加新属性？"><a href="#为什么我的对象无法添加新属性？" class="headerlink" title="为什么我的对象无法添加新属性？"></a>为什么我的对象无法添加新属性？</h2><p>今天在网上看到一个问题，在typescript中定义了一个对象，却无法添加新属性，代码如下：</p>
<figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> obj = &#123;&#125;;</span><br><span class="line">obj.<span class="property">prop</span> = <span class="string">&#x27;value&#x27;</span>; <span class="comment">// Error: TS2339: Property prop does not exist on type &#123;&#125;</span></span><br></pre></td></tr></table></figure>
<p>乍一看到这个问题，我有点疑惑，为什么要这样写呢？我以往的习惯是，需要使用什么类型，都会提前定义好，然后使用就行了，这个类型包括哪些属性，都是提前设置好的。但是这段代码里面的<code>obj</code>是一个空对象，什么属性都没有，感觉实际应用中这种情况很少。</p>
<p>但是作为一个典型的例子研究一下，还是不错的。这个错误产生的原因是作者对于typescript中的索引签名(<code>index signature</code>)不熟悉导致的。我们来分析一下原因。</p>
<h2 id="索引签名"><a href="#索引签名" class="headerlink" title="索引签名"></a>索引签名</h2><p>typescript在解析<code>obj</code>的时候，并不知道它里面会有哪些属性，属性的key是什么类型？属性的值又是什么类型？完全不知道，所以当用户试图添加一个新属性的时候，typescript就会报错。<br>解决的办法也很简单，我们需要提前告知typescript这些关于属性的信息。这个信息就是索引签名</p>
<figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">interface</span> looseObject &#123;</span><br><span class="line">  [<span class="attr">key</span>: <span class="built_in">string</span>]: <span class="built_in">any</span>; <span class="comment">// 添加索引签名：属性名是字符串类型，属性值是任意类型</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="attr">obj</span>: looseObject = &#123;&#125;;</span><br><span class="line">obj.<span class="property">prop</span> = <span class="string">&#x27;value&#x27;</span>; <span class="comment">// OK</span></span><br></pre></td></tr></table></figure>

<h2 id="使用Record类型"><a href="#使用Record类型" class="headerlink" title="使用Record类型"></a>使用<code>Record</code>类型</h2><p>这个例子更简单的办法是使用<code>Record</code>类型，<code>Record</code>类型在定义特定类型的对象时特别有用。<code>Record&lt;string, any&gt;</code>表示一个对象类型，其属性名是字符串类型，属性值可以是任意类型。</p>
<figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="attr">obj</span>: <span class="title class_">Record</span>&lt;<span class="built_in">string</span>, <span class="built_in">any</span>&gt; = &#123;&#125;;</span><br><span class="line">obj.<span class="property">prop</span> = <span class="string">&#x27;value&#x27;</span>; <span class="comment">// OK</span></span><br></pre></td></tr></table></figure>

<h2 id="索引签名的使用场景"><a href="#索引签名的使用场景" class="headerlink" title="索引签名的使用场景"></a>索引签名的使用场景</h2><p>那么什么场景下需要使用索引签名呢？一般来说，当属性的个数不固定的时候，就需要使用索引签名了。</p>
<h3 id="统计学生成绩"><a href="#统计学生成绩" class="headerlink" title="统计学生成绩"></a>统计学生成绩</h3><p>比如要统计学生成绩，每个科目对应一个分数，不同专业的学生科目是不一样的，这时候就可以使用索引签名来定义一个对象类型。</p>
<figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">interface</span> <span class="title class_">StudentScores</span> &#123;</span><br><span class="line">  [<span class="attr">subject</span>: <span class="built_in">string</span>]: <span class="built_in">number</span>; <span class="comment">// 科目名是字符串类型，分数是数字类型</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="attr">scores</span>: <span class="title class_">StudentScores</span> = &#123;</span><br><span class="line">  <span class="attr">math</span>: <span class="number">90</span>,</span><br><span class="line">  <span class="attr">english</span>: <span class="number">85</span>,</span><br><span class="line">  <span class="attr">physics</span>: <span class="number">92</span>,</span><br><span class="line">&#125;;</span><br><span class="line">scores.<span class="property">chemistry</span> = <span class="number">88</span>; <span class="comment">// 可以添加新的科目</span></span><br></pre></td></tr></table></figure>

<h3 id="CSS-In-JS的使用"><a href="#CSS-In-JS的使用" class="headerlink" title="CSS-In-JS的使用"></a>CSS-In-JS的使用</h3><p>在CSS-In-JS的场景中，通常需要动态添加样式属性，这时候索引签名也非常有用。下面的代码定义了一个主题(Theme)，其中包括<code>color</code>和<code>spacing</code>属性，对于<code>color</code>属性，我们不可能列出所有可能的颜色名称，这时候可以使用索引签名就非常有用了。<code>spacing</code>也是同样的道理。</p>
<figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> <span class="title class_">Theme</span> = &#123;</span><br><span class="line">  <span class="attr">colors</span>: &#123;</span><br><span class="line">    [<span class="attr">colorName</span>: <span class="built_in">string</span>]: <span class="built_in">string</span>;</span><br><span class="line">  &#125;;</span><br><span class="line">  <span class="attr">spacing</span>: &#123;</span><br><span class="line">    [<span class="attr">size</span>: <span class="built_in">string</span>]: <span class="built_in">number</span>;</span><br><span class="line">  &#125;;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>今天就到这里了，祝大家编程愉快，喜欢就点个关注，我要去打弹弓了，明天见！</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="en">
    <link itemprop="mainEntityOfPage" href="https://frontendthink.com/2025/07/05/typescript-structural-typing-usecase/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="Philip Zhang">
      <meta itemprop="description" content="青春都一餉，忍把浮名換了代碼輕狂。">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Philip">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2025/07/05/typescript-structural-typing-usecase/" class="post-title-link" itemprop="url">typescript-structural-typing-usecase</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>

              <time title="Created: 2025-07-05 08:26:42" itemprop="dateCreated datePublished" datetime="2025-07-05T08:26:42+08:00">2025-07-05</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">Edited on</span>
                <time title="Modified: 2025-07-07 00:07:57" itemprop="dateModified" datetime="2025-07-07T00:07:57+08:00">2025-07-07</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">In</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/typescript/" itemprop="url" rel="index"><span itemprop="name">typescript</span></a>
                </span>
                  , 
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/typescript/type/" itemprop="url" rel="index"><span itemprop="name">type</span></a>
                </span>
            </span>

          <br>
            <span class="post-meta-item" title="Symbols count in article">
              <span class="post-meta-item-icon">
                <i class="far fa-file-word"></i>
              </span>
                <span class="post-meta-item-text">Symbols count in article: </span>
              <span>1.3k</span>
            </span>
            <span class="post-meta-item" title="Reading time">
              <span class="post-meta-item-icon">
                <i class="far fa-clock"></i>
              </span>
                <span class="post-meta-item-text">Reading time &asymp;</span>
              <span>5 mins.</span>
            </span>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h2 id="介绍"><a href="#介绍" class="headerlink" title="介绍"></a>介绍</h2><p>结构化类型是typescript类型系统的一个重要特性，如果不了解这个特性，则经常会被typescript的行为搞得一头雾水，导致我们期待的行为与实际的行为不一致。今天我们就来看两个例子。</p>
<p>不了解结构化类型的同学，可以先看看这篇：<a href="https://frontendthink.com/2025/07/04/javascript-structural-typing/">TypeScript结构化类型初探</a></p>
<h2 id="第一个例子"><a href="#第一个例子" class="headerlink" title="第一个例子"></a>第一个例子</h2><p>下面的代码定义了一个<code>Person</code>类型</p>
<figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">interface</span> <span class="title class_">Person</span> &#123;</span><br><span class="line">  <span class="attr">name</span>: <span class="built_in">string</span>;</span><br><span class="line">  <span class="attr">age</span>: <span class="built_in">number</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>然后又定义了一个函数打印这个类型的对象</p>
<figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">printPerson</span>(<span class="params"><span class="attr">person</span>: <span class="title class_">Person</span></span>) &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">`Name: <span class="subst">$&#123;person.name&#125;</span>, Age: <span class="subst">$&#123;person.age&#125;</span>`</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>按道理来说，要调用这个函数，必须传递一个<code>Person</code>类型的对象，但是你会发现，直接传一个对象进去也行。</p>
<figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="title function_">printPerson</span>(&#123; <span class="attr">name</span>: <span class="string">&quot;Alice&quot;</span>, <span class="attr">age</span>: <span class="number">30</span> &#125;);</span><br></pre></td></tr></table></figure>
<p>这段代码没有报错，为什么呢？因为typescript的结构化类型系统认为，只要传入的对象包含了<code>Person</code>类型所需的所有属性，就可以被认为是<code>Person</code>类型。你甚至可以多加一些属性，比如：</p>
<figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="title function_">printPerson</span>(&#123; <span class="attr">name</span>: <span class="string">&quot;Alice&quot;</span>, <span class="attr">age</span>: <span class="number">30</span>, <span class="attr">location</span>: <span class="string">&quot;Wonderland&quot;</span> &#125;);</span><br></pre></td></tr></table></figure>
<p>代码一样可以正常运行！</p>
<p>为什么？因为在typescript中，类型是<code>基于结构</code>的，而不是基于名称的。只要对象的结构符合要求，就可以被认为是该类型。如果一个类型A包含了类型B的所有属性，那么类型A就可以被认为是类型B。在使用类型B的地方，就可以使用类型A代替。</p>
<h2 id="第二个例子"><a href="#第二个例子" class="headerlink" title="第二个例子"></a>第二个例子</h2><p>还是以上面的<code>Person</code>类型为例，假设我们要打印<code>Person</code>对象中的所有属性，有的同学可能不假思索的写下如下代码：</p>
<figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">interface</span> <span class="title class_">Person</span> &#123;</span><br><span class="line">  <span class="attr">name</span>: <span class="built_in">string</span>;</span><br><span class="line">  <span class="attr">age</span>: <span class="built_in">number</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="attr">person</span>: <span class="title class_">Person</span> = &#123; <span class="attr">name</span>: <span class="string">&quot;Alice&quot;</span>, <span class="attr">age</span>: <span class="number">30</span> &#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">printProperties</span>(<span class="params"><span class="attr">person</span>: <span class="title class_">Person</span></span>) &#123;</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">const</span> property <span class="keyword">in</span> person) &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">`<span class="subst">$&#123;property&#125;</span>: <span class="subst">$&#123;person[property]&#125;</span>`</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="title function_">printProperties</span>(person);</span><br></pre></td></tr></table></figure>
<p>但是这段代码却报错了：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">TS7053: Element implicitly has an <span class="string">&#x27;any&#x27;</span> <span class="built_in">type</span> because expression of <span class="built_in">type</span> <span class="string">&#x27;string&#x27;</span> can<span class="string">&#x27;t be used to index type &#x27;</span>Person<span class="string">&#x27;. No index signature with a parameter of type &#x27;</span>string<span class="string">&#x27; was found on type &#x27;</span>Person<span class="string">&#x27;.</span></span><br></pre></td></tr></table></figure>
<p>当我第一次看到这个错误时，我只想撞墙，我哪里用<code>any</code>了，这不是胡扯吗？但这不是对待错误的正确态度，这种错误如果不彻底解决，那么它就会一直困扰你，只有将它彻底击败，下次再遇到时才能得心应手！</p>
<p>仔细看一下这个报错，它大概描述了两件事情：</p>
<ol>
<li><code>string</code>类型的值不能用来索引<code>Person</code>类型。</li>
<li><code>Person</code>类型没有定义索引签名。</li>
</ol>
<p>其实这两件事本质上说的是一个问题，那就是在TypeScript中，只有在类型中显式定义了索引签名，才能使用<code>string</code>类型的值来索引该类型。那么我们就给<code>Person</code>类型添加一个索引签名：</p>
<h3 id="方式一：为Person类型添加索引签名"><a href="#方式一：为Person类型添加索引签名" class="headerlink" title="方式一：为Person类型添加索引签名"></a>方式一：为<code>Person</code>类型添加索引签名</h3><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">interface</span> <span class="title class_">Person</span> &#123;</span><br><span class="line">  <span class="attr">name</span>: <span class="built_in">string</span>;</span><br><span class="line">  <span class="attr">age</span>: <span class="built_in">number</span>;</span><br><span class="line">  [<span class="attr">key</span>: <span class="built_in">string</span>]: <span class="built_in">any</span>; <span class="comment">// 索引签名</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p><code>[key: string]: any;</code> 这行代码的意思是，<code>Person</code>类型可以有任意数量的属性，属性名必须是字符串类型 (<code>[key: string]</code>)，属性值可以是任意类型(<code>any</code>)。</p>
</blockquote>
<p>现在我们再来运行<code>printProperties</code>函数，就不会报错了。</p>
<h3 id="方式二：使用keyof关键字"><a href="#方式二：使用keyof关键字" class="headerlink" title="方式二：使用keyof关键字"></a>方式二：使用<code>keyof</code>关键字</h3><p>坦白的说，为了一个遍历函数给<code>Person</code>类型添加一个索引签名有点过于冗余了，其实我们可以使用另一个方法来解决这个问题，那就是使用<code>keyof</code>关键字来获取<code>Person</code>类型的所有属性名。</p>
<figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">printProperties</span>(<span class="params"><span class="attr">person</span>: <span class="title class_">Person</span></span>) &#123;</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">const</span> property <span class="keyword">in</span> person) &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">`<span class="subst">$&#123;property&#125;</span>: <span class="subst">$&#123;person[property <span class="keyword">as</span> keyof <span class="keyword">typeof</span> person]&#125;</span>`</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>来看这一句代码<code>property as keyof typeof person</code>, 它的执行步骤是这样的：</p>
<ol>
<li>先执行<code>typeof person</code>，得到<code>Person</code>类型。</li>
<li>再执行<code>keyof Person</code>，得到<code>Person</code>类型的所有属性名的联合类型 - <code>name | age</code>。</li>
<li>最后使用<code>as</code>操作符将<code>property</code>转换为这个联合类型。</li>
</ol>
<p>这样做的好处是，<code>property</code>的类型被限制为<code>Person</code>类型的属性名，在本例中就是<code>name</code>和<code>age</code>这两个属性，绝不会超出这个范围，这样就可以安全地索引<code>person</code>对象了。</p>
<p>眼力好的同学可能已经发现了，上面这个写法可以简化一下，<code>property as keyof typeof person</code>可以简化为<code>property as keyof Person</code>，因为<code>person</code>的类型就是<code>Person</code>，所以我们可以直接使用<code>Person</code>类型来代替。这样可以节省一个<code>typeof</code>操作符的使用。</p>
<h3 id="方式三：使用Object-entries"><a href="#方式三：使用Object-entries" class="headerlink" title="方式三：使用Object.entries"></a>方式三：使用<code>Object.entries</code></h3><p>当然，我们还可以使用<code>Object.entries</code>方法来遍历对象的属性，这样就不需要担心索引签名的问题了。</p>
<figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">printProperty</span>(<span class="params"><span class="attr">person</span>: <span class="title class_">Person</span></span>) &#123;</span><br><span class="line">  <span class="title class_">Object</span>.<span class="title function_">entries</span>(person).<span class="title function_">forEach</span>(<span class="function">(<span class="params">[key, value]</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">`<span class="subst">$&#123;key&#125;</span>: <span class="subst">$&#123;value&#125;</span>`</span>);</span><br><span class="line">  &#125;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>分析一下这段代码：</p>
<ol>
<li><code>Object.entries</code>方法会返回一个二维数组，其中每个元素又是一个数组，这个数组包含了对象的属性名和属性值。以上面的<code>person</code>对象为例，<code>Object.entries(person)</code>会返回<code>[[&#39;name&#39;, &#39;Alice&#39;], [&#39;age&#39;, 30]]</code>，</li>
<li>接下来的<code>forEach</code>方法会遍历这个数组，这里使用了一个数组解构操作符<code>([key, value])</code>，将每个属性的名字赋值给key，属性的值赋值给value，</li>
<li>最后使用<code>console.log</code>打印出来。</li>
</ol>
<p>我比较喜欢方式三，简洁易懂，无需额外的操作。</p>
<p>今天就到这里了，觉得有用就点个关注吧，我们下次再见，我要去打弹弓了。</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="en">
    <link itemprop="mainEntityOfPage" href="https://frontendthink.com/2025/07/04/javascript-structural-typing/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="Philip Zhang">
      <meta itemprop="description" content="青春都一餉，忍把浮名換了代碼輕狂。">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Philip">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2025/07/04/javascript-structural-typing/" class="post-title-link" itemprop="url">javascript-structural-typing</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>

              <time title="Created: 2025-07-04 22:52:42" itemprop="dateCreated datePublished" datetime="2025-07-04T22:52:42+08:00">2025-07-04</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">Edited on</span>
                <time title="Modified: 2025-07-05 08:18:44" itemprop="dateModified" datetime="2025-07-05T08:18:44+08:00">2025-07-05</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">In</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/javascript/" itemprop="url" rel="index"><span itemprop="name">javascript</span></a>
                </span>
                  , 
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/javascript/type/" itemprop="url" rel="index"><span itemprop="name">type</span></a>
                </span>
            </span>

          <br>
            <span class="post-meta-item" title="Symbols count in article">
              <span class="post-meta-item-icon">
                <i class="far fa-file-word"></i>
              </span>
                <span class="post-meta-item-text">Symbols count in article: </span>
              <span>984</span>
            </span>
            <span class="post-meta-item" title="Reading time">
              <span class="post-meta-item-icon">
                <i class="far fa-clock"></i>
              </span>
                <span class="post-meta-item-text">Reading time &asymp;</span>
              <span>4 mins.</span>
            </span>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h2 id="啥是鸭子类型？"><a href="#啥是鸭子类型？" class="headerlink" title="啥是鸭子类型？"></a>啥是鸭子类型？</h2><p>作为一个前端程序员，想必大家都知道javascript是一个弱类型语言，如果需要类型的支持，那就需要借助typescript来实现，但是大家可曾听过这样一个说法？</p>
<blockquote>
<p>javascript属于鸭子类型</p>
</blockquote>
<p>当我第一次看到这个说法时，我不禁哈哈大笑，鸭子类型是啥？其实这不过是一个比喻而已，鸭子类型的意思是：</p>
<blockquote>
<p>如果一个动物看起来像鸭子，游起泳来像鸭子，叫起来也像鸭子，那么它大概率就是鸭子。</p>
</blockquote>
<h2 id="结构化类型"><a href="#结构化类型" class="headerlink" title="结构化类型"></a>结构化类型</h2><p>TypeScript使用<code>结构化类型（Structural Typing）</code>来实现javascript中的鸭子类型，结构化类型描述的是两个类型之间的兼容性，我们看一个具体的例子，再下结论。</p>
<p>假设你正在开发一个3D图形应用程序，这个程序最基本的功能就是绘制图形，而绘制图形最基本的数据结构就是点，我们先定义一个2D点。</p>
<figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">interface</span> <span class="title class_">Point2D</span> &#123;</span><br><span class="line">  <span class="attr">x</span>: <span class="built_in">number</span>;</span><br><span class="line">  <span class="attr">y</span>: <span class="built_in">number</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>当然，要绘制3D图形，我们还需要一个3D点。</p>
<figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">interface</span> <span class="title class_">Point3D</span> &#123;</span><br><span class="line">  <span class="attr">x</span>: <span class="built_in">number</span>;</span><br><span class="line">  <span class="attr">y</span>: <span class="built_in">number</span>;</span><br><span class="line">  <span class="attr">z</span>: <span class="built_in">number</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>现在我们可以下结论了，<code>Point3D</code>与<code>Point2D</code>是兼容的，因为<code>Point3D</code>包含了所有<code>Point2D</code>的属性。</p>
<p>所以结构化类型的定义如下：</p>
<blockquote>
<p>如果一个类型B包含了另一个类型A的所有属性，那么这两个类型是兼容的，我们可以将类型B赋值给类型A。</p>
</blockquote>
<p>需要注意的是，这种兼容性是单向的，<code>Point3D</code>可以赋值给<code>Point2D</code>，但反之不行，因为<code>Point2D</code>缺少了<code>z</code>属性。</p>
<p>其实这不难理解，假设我们要绘制一条2D线段，需要两个点来表示这条线段的起点和终点。</p>
<figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">drawLine</span>(<span class="params"><span class="attr">start</span>: <span class="title class_">Point2D</span>, <span class="attr">end</span>: <span class="title class_">Point2D</span></span>) &#123;</span><br><span class="line">  <span class="comment">// 绘制线段的逻辑</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>那么如果我们传入的是<code>Point3D</code>类型的点，程序依然可以正常工作，因为<code>Point3D</code>包含了<code>Point2D</code>的所有属性。多出来的<code>z</code>属性直接忽略，并不影响结果。</p>
<figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="attr">start</span>: <span class="title class_">Point3D</span> = &#123; <span class="attr">x</span>: <span class="number">0</span>, <span class="attr">y</span>: <span class="number">0</span>, <span class="attr">z</span>: <span class="number">0</span> &#125;;</span><br><span class="line"><span class="keyword">const</span> <span class="attr">end</span>: <span class="title class_">Point3D</span> = &#123; <span class="attr">x</span>: <span class="number">1</span>, <span class="attr">y</span>: <span class="number">1</span>, <span class="attr">z</span>: <span class="number">1</span> &#125;;</span><br><span class="line"><span class="title function_">drawLine</span>(start, end); <span class="comment">// 依然可以正常绘制线段</span></span><br></pre></td></tr></table></figure>

<p>我们甚至不需要传递一个<code>Point3D</code>类型的点，任意一个包含<code>x</code>和<code>y</code>属性的对象都可以作为参数传递给<code>drawLine</code>函数。</p>
<figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> start = &#123; <span class="attr">x</span>: <span class="number">0</span>, <span class="attr">y</span>: <span class="number">0</span> &#125;;</span><br><span class="line"><span class="keyword">const</span> end = &#123; <span class="attr">x</span>: <span class="number">1</span>, <span class="attr">y</span>: <span class="number">1</span> &#125;;</span><br><span class="line"><span class="title function_">drawLine</span>(start, end); <span class="comment">// 依然可以正常绘制线段</span></span><br></pre></td></tr></table></figure>
<p>这就是结构化类型的威力，也是JavaScript的灵活性所在。</p>
<h2 id="名义类型"><a href="#名义类型" class="headerlink" title="名义类型"></a>名义类型</h2><p>与结构化类型对应的是<code>名义类型（Nominal Typing）</code>，比如<code>Java</code>和<code>C#</code>这种强类型语言，使用的都是名义类型，名义类型要求类型的名称必须匹配才能兼容。也就是说，只有当两个类型的名称完全相同或者存在继承关系时，它们才被认为是兼容的。</p>
<p>对于<code>Java</code>或者<code>C#</code>这样的强类型语言来说，上面<code>drawLine</code>的例子就不成立了，因为<code>Point2D</code>和<code>Point3D</code>是两个不同的类型，即使它们有相同的属性，也不能互相替换。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Point2D</span> &#123;</span><br><span class="line">    <span class="type">int</span> x;</span><br><span class="line">    <span class="type">int</span> y;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Point3D</span> &#123;</span><br><span class="line">    <span class="type">int</span> x;</span><br><span class="line">    <span class="type">int</span> y;</span><br><span class="line">    <span class="type">int</span> z;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">void</span> <span class="title function_">drawLine</span><span class="params">(Point2D start, Point2D end)</span> &#123;</span><br><span class="line">    <span class="comment">// 绘制线段的逻辑</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">Point3D</span> <span class="variable">start</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Point3D</span>(); <span class="comment">// 定义起点</span></span><br><span class="line"><span class="type">Point3D</span> <span class="variable">end</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Point3D</span>(); <span class="comment">// 定义终点</span></span><br><span class="line">drawLine(start, end); <span class="comment">// 编译错误，Point3D不是Point2D类型</span></span><br></pre></td></tr></table></figure>

<p>基于这个原因，在强类型语言中如果要实现类型兼容性的话，只能通过继承来实现。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Point2D</span> &#123;</span><br><span class="line">    <span class="type">int</span> x;</span><br><span class="line">    <span class="type">int</span> y;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Point3D</span> <span class="keyword">extends</span> <span class="title class_">Point2D</span> &#123;</span><br><span class="line">    <span class="type">int</span> z;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">void</span> <span class="title function_">drawLine</span><span class="params">(Point2D start, Point2D end)</span> &#123;</span><br><span class="line">    <span class="comment">// 绘制线段的逻辑</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">Point3D</span> <span class="variable">start</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Point3D</span>(); <span class="comment">// 定义起点</span></span><br><span class="line"><span class="type">Point3D</span> <span class="variable">end</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Point3D</span>(); <span class="comment">// 定义终点</span></span><br><span class="line">drawLine(start, end); <span class="comment">// 现在可以正常工作</span></span><br></pre></td></tr></table></figure>

<p>上面的例子中，<code>Point3D</code>继承自<code>Point2D</code>，这就意味着<code>Point3D</code>是一个<code>Point2D</code>类型的对象，可以在需要<code>Point2D</code>的地方使用。</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="en">
    <link itemprop="mainEntityOfPage" href="https://frontendthink.com/2025/07/01/javascript-quine/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="Philip Zhang">
      <meta itemprop="description" content="青春都一餉，忍把浮名換了代碼輕狂。">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Philip">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2025/07/01/javascript-quine/" class="post-title-link" itemprop="url">javascript-quine</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>

              <time title="Created: 2025-07-01 19:47:42" itemprop="dateCreated datePublished" datetime="2025-07-01T19:47:42+08:00">2025-07-01</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">Edited on</span>
                <time title="Modified: 2025-07-08 22:17:07" itemprop="dateModified" datetime="2025-07-08T22:17:07+08:00">2025-07-08</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">In</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/javascript/" itemprop="url" rel="index"><span itemprop="name">javascript</span></a>
                </span>
            </span>

          <br>
            <span class="post-meta-item" title="Symbols count in article">
              <span class="post-meta-item-icon">
                <i class="far fa-file-word"></i>
              </span>
                <span class="post-meta-item-text">Symbols count in article: </span>
              <span>858</span>
            </span>
            <span class="post-meta-item" title="Reading time">
              <span class="post-meta-item-icon">
                <i class="far fa-clock"></i>
              </span>
                <span class="post-meta-item-text">Reading time &asymp;</span>
              <span>3 mins.</span>
            </span>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h2 id="介绍"><a href="#介绍" class="headerlink" title="介绍"></a>介绍</h2><p>如何写一段javascript程序，输出自身的源代码？这个问题非常有意思，大家不妨先尝试一下，反正在尝试了半个小时之后，我果断放弃了。</p>
<p>这种能输出自身的程序在英文里被称为<code>quine</code>。</p>
<h2 id="准备知识"><a href="#准备知识" class="headerlink" title="准备知识"></a>准备知识</h2><p>其实要实现这样一段程序，至少要掌握javascript中两个重要的知识点：</p>
<ol>
<li>IIFE</li>
<li>toString()方法</li>
</ol>
<p>关于IIFE，之前的文章已经做过详细的介绍，这里就不再赘述了，感兴趣的同学可以先去看一下。</p>
<p><a href="https://frontendthink.com/2025/06/29/javascript-iife/">JavaScript IIFE</a></p>
<p>关于<code>toString()</code>方法，相信大家也不陌生，但是你可知道对于一个函数来说，调用<code>toString()</code>方法意味着什么？</p>
<p>没错，调用一个函数的<code>toString()</code>方法会返回这个函数的源代码。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">foo</span>(<span class="params"></span>) &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;hello world&#x27;</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(foo.<span class="title function_">toString</span>()) <span class="comment">// 输出foo的源代码</span></span><br></pre></td></tr></table></figure>

<h2 id="第一个例子"><a href="#第一个例子" class="headerlink" title="第一个例子"></a>第一个例子</h2><p>有了上面的知识储备，我们可以动手写一下了，首先写一个函数<code>foo</code>，在函数体内调用<code>console.log(foo.toString())</code>输出函数的源代码。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">foo</span>(<span class="params"></span>) &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(foo.<span class="title function_">toString</span>())</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>但是这只是函数定义，并未执行，所以需要在函数定义之后调用它。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">foo</span>(<span class="params"></span>) &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(foo.<span class="title function_">toString</span>())</span><br><span class="line">&#125;</span><br><span class="line"><span class="title function_">foo</span>() <span class="comment">// 调用函数，输出源代码</span></span><br></pre></td></tr></table></figure>
<p>运行上面的代码，输出的结果如下所示，可以看到最后的调用语句<code>foo()</code>并没有打印出来。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">foo</span>(<span class="params"></span>) &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(foo.<span class="title function_">toString</span>())</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这不符合我们的要求，所以考虑去掉调用语句，将函数改为IIFE的形式</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">(<span class="keyword">function</span> <span class="title function_">foo</span>(<span class="params"></span>) &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(foo.<span class="title function_">toString</span>())</span><br><span class="line">&#125;)()</span><br></pre></td></tr></table></figure>
<p>运行上面的代码，输出的结果如下，最外层的<code>()</code>和末尾调用函数的<code>()</code>没有打印出来，这也不符合我们的要求。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">foo</span>(<span class="params"></span>) &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(foo.<span class="title function_">toString</span>())</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>改造一下内部的<code>console.log</code>，将两组括弧也输出来。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">(<span class="keyword">function</span> <span class="title function_">foo</span>(<span class="params"></span>) &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;(&#x27;</span> + foo.<span class="title function_">toString</span>() + <span class="string">&#x27;)()&#x27;</span>)</span><br><span class="line">&#125;)()</span><br></pre></td></tr></table></figure>
<p>这回结果终于正确了，我们进一步改造，使用<code>+</code>拼接字符串时，js会自动将<code>+</code>另一侧的操作数转换为字符串，所以我们可以把<code>toString()</code>省略掉。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">(<span class="keyword">function</span> <span class="title function_">foo</span>(<span class="params"></span>) &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;(&#x27;</span> + foo + <span class="string">&#x27;)()&#x27;</span>)</span><br><span class="line">&#125;)()</span><br></pre></td></tr></table></figure>

<p>再增加点神秘感，将foo换成<code>$</code></p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">(<span class="keyword">function</span> <span class="title function_">$</span>(<span class="params"></span>) &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;(&#x27;</span> + $ + <span class="string">&#x27;)()&#x27;</span>)</span><br><span class="line">&#125;)()</span><br></pre></td></tr></table></figure>
<p>运行结果如下：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">(<span class="keyword">function</span> <span class="title function_">$</span>(<span class="params"></span>) &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;(&#x27;</span> + $ + <span class="string">&#x27;)()&#x27;</span>)</span><br><span class="line">&#125;)()</span><br></pre></td></tr></table></figure>
<p>这就是一个简单的javascript quine了。</p>
<h2 id="最短的例子"><a href="#最短的例子" class="headerlink" title="最短的例子"></a>最短的例子</h2><p>在上面的例子中，为了便于观察结果，使用了<code>console.log</code>输出了源代码，实际上我们可以直接返回源代码，这样就可以省略掉<code>console.log</code>语句。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">(<span class="keyword">function</span> <span class="title function_">$</span>(<span class="params"></span>) &#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="string">&#x27;(&#x27;</span> + $ + <span class="string">&#x27;)()&#x27;</span></span><br><span class="line">&#125;)()</span><br></pre></td></tr></table></figure>

<p>根据前面两篇文章学到的<code>IIFE</code>的知识，我们使用IIFE的箭头函数形式。下面这段代码定义一个箭头函数并将其赋值给变量<code>$</code>，然后立即执行这个函数。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">($ = <span class="function">() =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="string">&#x27;(&#x27;</span> + $ + <span class="string">&#x27;)()&#x27;</span></span><br><span class="line">&#125;)()</span><br></pre></td></tr></table></figure>
<p>但是它的执行结果中没有包含<code>$</code>，我们加上<code>$</code></p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">($ = <span class="function">() =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="string">&#x27;($ =&#x27;</span> + $ + <span class="string">&#x27;)()&#x27;</span></span><br><span class="line">&#125;)()</span><br></pre></td></tr></table></figure>

<p>根据箭头函数的规则，如果返回值只有一行，那么可以省略掉大括号<code>&#123;&#125;</code>和<code>return</code>关键字，所以我们可以进一步简化为</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">($ = <span class="function">() =&gt;</span> <span class="string">&#x27;($ =&#x27;</span> + $ + <span class="string">&#x27;)()&#x27;</span>)()</span><br></pre></td></tr></table></figure>
<p>再将字符串拼接操作改为ES6的模板字符串形式：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">($ = <span class="function">() =&gt;</span> <span class="string">`($ = <span class="subst">$&#123;$&#125;</span>)()`</span>)()</span><br></pre></td></tr></table></figure>
<p>最后去掉空格，得到如下代码。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">($=<span class="function">()=&gt;</span><span class="string">`($=<span class="subst">$&#123;$&#125;</span>)()`</span>)()</span><br></pre></td></tr></table></figure>
<p>这就是史上最短的<code>javascript quine</code>了。需要注意的是，上面的代码需要在浏览器的控制台中运行，如果在IDE中运行，代码格式化工具可能会将代码格式化，导致结果不正确。</p>
<p>你还能想到其他办法吗？欢迎在评论区分享你的想法。</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="en">
    <link itemprop="mainEntityOfPage" href="https://frontendthink.com/2025/06/30/javascript-iife-history/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="Philip Zhang">
      <meta itemprop="description" content="青春都一餉，忍把浮名換了代碼輕狂。">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Philip">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2025/06/30/javascript-iife-history/" class="post-title-link" itemprop="url">javascript-iife-history</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>
              

              <time title="Created: 2025-06-30 22:14:00 / Modified: 23:18:45" itemprop="dateCreated datePublished" datetime="2025-06-30T22:14:00+08:00">2025-06-30</time>
            </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">In</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/javascript/" itemprop="url" rel="index"><span itemprop="name">javascript</span></a>
                </span>
            </span>

          <br>
            <span class="post-meta-item" title="Symbols count in article">
              <span class="post-meta-item-icon">
                <i class="far fa-file-word"></i>
              </span>
                <span class="post-meta-item-text">Symbols count in article: </span>
              <span>1.4k</span>
            </span>
            <span class="post-meta-item" title="Reading time">
              <span class="post-meta-item-icon">
                <i class="far fa-clock"></i>
              </span>
                <span class="post-meta-item-text">Reading time &asymp;</span>
              <span>5 mins.</span>
            </span>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h2 id="介绍"><a href="#介绍" class="headerlink" title="介绍"></a>介绍</h2><p>IIFE(Immediately Invoked Function Expression)，中文名称：立即执行函数表达式，其实IIFE最早并不叫这个名字，而是叫做<code>Self-Executing Anonymous Function</code>，即自执行匿名函数。根据MDN的资料，IIFE这个说法最早由Ben Alman于2010年提出，下面我们一起来看看这个名字的来龙去脉。</p>
<p>2010年11月5日，Ben Alman写下来他的著名文章：<a target="_blank" rel="noopener" href="https://web.archive.org/web/20171201033208/http://benalman.com/news/2010/11/immediately-invoked-function-expression/#iife">Immediately-Invoked Function Expression (IIFE)</a>，标志着IIFE这个名字的诞生。</p>
<p>在文章中，Ben Alman称他是一个对待术语非常严谨的人，之前他多次看到<code>Self-Executing Anonymous Function</code>这个说法，觉得不是很恰当，于是他提出了<code>Immediately-Invoked Function Expression</code>这个说法。</p>
<h2 id="IIFE到底是咋来的？"><a href="#IIFE到底是咋来的？" class="headerlink" title="IIFE到底是咋来的？"></a>IIFE到底是咋来的？</h2><p>当我们定义一个函数或者一个函数表达式时，你得到的是一个名字，通过这个名字，你就可以调用这个函数。</p>
<p>下面这两段代码，第一个定义了一个普通函数，第二个定义了一个函数表达式，这两种形式，我们都可以通过标识符<code>foo</code>来调用它们。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 普通函数</span></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">foo</span>(<span class="params"></span>) &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;I am a function&#x27;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 函数表达式</span></span><br><span class="line"><span class="keyword">const</span> foo = <span class="keyword">function</span>(<span class="params"></span>) &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;I am a function expression&#x27;</span>);</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>也就是说，当<code>javascript</code>解释器遇到全局<code>function</code>关键字，或者一个函数内部的<code>function</code>关键字时，会将其解释为一个函数声明。</p>
<p>然而函数声明是无法直接调用的，所以下面的写法会导致错误：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">foo</span>(<span class="params"></span>) &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;I am a function&#x27;</span>); <span class="comment">// Uncaught SyntaxError: Unexpected token &#x27;)&#x27;</span></span><br><span class="line">&#125;();</span><br></pre></td></tr></table></figure>

<p>我们来分析一下，上面这段代码，javascript解释器会将其解释为一个函数声明，和一个分组操作符(<code>()</code>), 分组操作符是用来改变运算符优先级的，里面必须有表达式才行，所以javascript解释器会报错。</p>
<p>那我们就给它一个表达式：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">foo</span>(<span class="params"></span>) &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;I am a function&#x27;</span>); <span class="comment">// Uncaught SyntaxError: Unexpected token &#x27;)&#x27;</span></span><br><span class="line">&#125;(<span class="number">1</span>);</span><br></pre></td></tr></table></figure>
<p>这回代码不报错了，但是这段代码毫无意义，这个函数并没有执行，实际上这段代码与下面的代码等价：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">foo</span>(<span class="params"></span>) &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;I am a function&#x27;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">(<span class="number">1</span>);</span><br></pre></td></tr></table></figure>
<p>它的返回值就是1，这不是我们想要的结果，我们需要函数定义后能立即被执行，那就需要我们告诉javascript解释器，这个函数是一个表达式，而不是一个声明，因为表达式可以立即执行，但是声明不能。</p>
<p>而在javascript中，生成表达式最简单的方式就是用<code>()</code>包裹起来，于是有了下面的代码</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">(<span class="keyword">function</span> <span class="title function_">foo</span>(<span class="params"></span>) &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;I am a function&#x27;</span>);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>
<p>这样函数声明就变成了一个函数表达式，但是这个表达是没有名字，我们没法调用它，我们先给它一个名字，然后通过名字调用它。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> bar = (<span class="keyword">function</span> <span class="title function_">foo</span>(<span class="params"></span>) &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;I am a function&#x27;</span>);</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="title function_">bar</span>(); <span class="comment">// I am a function</span></span><br></pre></td></tr></table></figure>
<p>这样完全没有问题，但是这里的<code>bar</code>实在有点多余，实际上<code>bar</code>和</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">(<span class="keyword">function</span> <span class="title function_">foo</span>(<span class="params"></span>) &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;I am a function&#x27;</span>);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>
<p>是等价的，既然<code>bar()</code>可以调用函数，那么我们直接在函数表达式末尾加上<code>()</code>，也可以调用这个函数，于是就有了下面的代码，这就是IIFE的由来。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">(<span class="keyword">function</span> <span class="title function_">foo</span>(<span class="params"></span>) &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;I am a function&#x27;</span>);</span><br><span class="line">&#125;)();</span><br></pre></td></tr></table></figure>
<p>将<code>()</code>写在外层的括号内也一样，这种方式颇得javascript专家<a target="_blank" rel="noopener" href="https://www.crockford.com/fash.html">Douglas Crockford</a>的青睐。我本人更喜欢第一种。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">(<span class="keyword">function</span>(<span class="params"></span>) &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;I am a function&#x27;</span>);</span><br><span class="line">&#125;());</span><br></pre></td></tr></table></figure>

<h2 id="IIFE的变种"><a href="#IIFE的变种" class="headerlink" title="IIFE的变种"></a>IIFE的变种</h2><p>有上面介绍可知，生成IIFE的精髓就是<code>将函数声明变成函数表达式</code>，而在javascript中，生成表达式可不止使用<code>()</code>包裹起来这一种方式，还有很多其他的方式可以实现。于是IIFE也就是产生了诸多变种。</p>
<p>这个变种利用赋值运算符<code>=</code>来实现，赋值运算符是将右侧表达式的值赋值给左侧变量的，所以它右侧的部分被解析成了函数表达式及其调用。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> i = <span class="keyword">function</span>(<span class="params"></span>) &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;I am an IIFE&#x27;</span>);</span><br><span class="line">&#125;();</span><br></pre></td></tr></table></figure>

<p>下面的表中使用逻辑运算符来生成表达式。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="literal">true</span> &amp; (<span class="keyword">function</span>(<span class="params"></span>) &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;I am an IIFE&#x27;</span>);</span><br><span class="line">&#125;());</span><br></pre></td></tr></table></figure>

<p>还有下面这些，都是利用一元运算符来生成函数表达式。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">!<span class="keyword">function</span>(<span class="params"></span>)&#123; <span class="comment">/* code */</span> &#125;();</span><br><span class="line">~<span class="keyword">function</span>(<span class="params"></span>)&#123; <span class="comment">/* code */</span> &#125;();</span><br><span class="line">-<span class="keyword">function</span>(<span class="params"></span>)&#123; <span class="comment">/* code */</span> &#125;();</span><br><span class="line">+<span class="keyword">function</span>(<span class="params"></span>)&#123; <span class="comment">/* code */</span> &#125;();</span><br></pre></td></tr></table></figure>

<p>最后来一个不为人知的，<code>void</code>运算符会对其右侧的表达是求值然后返回<code>undefined</code>。（<code>void expression</code> - 先对<code>expression</code>求值，然后返回<code>undefined</code>）。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">void</span> <span class="keyword">function</span>(<span class="params"></span>) &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;I am an IIFE&#x27;</span>);</span><br><span class="line">&#125;();</span><br></pre></td></tr></table></figure>

<p>还有使用<code>new</code>运算符来生成IIFE，这种方式比较少见，因为它会创建一个新的对象。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">new</span> <span class="keyword">function</span>(<span class="params"></span>) &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;I am an IIFE&#x27;</span>);</span><br><span class="line">&#125;();</span><br></pre></td></tr></table></figure>
<p>这些方式都比较偏门了，不建议使用，只是用来帮助我们理解IIFE的。</p>
<h2 id="为什么Self-Executing-Anonymous-Function这个名字不好？"><a href="#为什么Self-Executing-Anonymous-Function这个名字不好？" class="headerlink" title="为什么Self-Executing Anonymous Function这个名字不好？"></a>为什么Self-Executing Anonymous Function这个名字不好？</h2><p><code>Ben Alman</code>认为这个名字有两个问题：</p>
<p><strong>Self-Executing</strong>：这个名字暗示函数会调用自己，但是实际上函数是立即被执行的，而不是调用它自身。<br>比如下面的几段代码都会调用自己，但是这并不是IIFE的语义。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 递归调用自身</span></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">foo</span>(<span class="params"></span>) &#123; <span class="title function_">foo</span>(); </span><br><span class="line"></span><br><span class="line"><span class="comment">// 使用arguments.callee调用自身</span></span><br><span class="line"><span class="keyword">const</span> foo = <span class="keyword">function</span>(<span class="params"></span>) &#123; <span class="variable language_">arguments</span>.<span class="title function_">callee</span>(); &#125;;</span><br></pre></td></tr></table></figure>

<p><strong>Anonymous</strong>：这个名字暗示函数是匿名的，但实际上函数可以有名字，也可以没有名字，比如下面的例子：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 有名字的IIFE</span></span><br><span class="line">(<span class="keyword">function</span> <span class="title function_">foo</span>(<span class="params"></span>) &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;I am an IIFE&#x27;</span>);</span><br><span class="line">&#125;)();</span><br></pre></td></tr></table></figure>

<h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><p><a target="_blank" rel="noopener" href="https://web.archive.org/web/20171201033208/http://benalman.com/news/2010/11/immediately-invoked-function-expression/#iife">https://web.archive.org/web/20171201033208/http://benalman.com/news/2010/11/immediately-invoked-function-expression/#iife</a></p>
<p>大家有时间可以去拜读<code>Ben Alman</code>的原文，大佬写的东西就是不一样，通俗易懂，是我辈楷模！</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="en">
    <link itemprop="mainEntityOfPage" href="https://frontendthink.com/2025/06/29/javascript-iife/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="Philip Zhang">
      <meta itemprop="description" content="青春都一餉，忍把浮名換了代碼輕狂。">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Philip">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2025/06/29/javascript-iife/" class="post-title-link" itemprop="url">javascript-IIFE</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>
              

              <time title="Created: 2025-06-29 16:57:32 / Modified: 23:20:35" itemprop="dateCreated datePublished" datetime="2025-06-29T16:57:32+08:00">2025-06-29</time>
            </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">In</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/javascript/" itemprop="url" rel="index"><span itemprop="name">javascript</span></a>
                </span>
            </span>

          <br>
            <span class="post-meta-item" title="Symbols count in article">
              <span class="post-meta-item-icon">
                <i class="far fa-file-word"></i>
              </span>
                <span class="post-meta-item-text">Symbols count in article: </span>
              <span>1.1k</span>
            </span>
            <span class="post-meta-item" title="Reading time">
              <span class="post-meta-item-icon">
                <i class="far fa-clock"></i>
              </span>
                <span class="post-meta-item-text">Reading time &asymp;</span>
              <span>4 mins.</span>
            </span>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h2 id="介绍"><a href="#介绍" class="headerlink" title="介绍"></a>介绍</h2><p>IIFE（Immediately Invoked Function Expression）中文名称：<code>立即执行函数表达式</code>，是一种JavaScript编程模式，它允许函数在定义后立即执行。由这个定义可以看出IIFE有两个特点：</p>
<ol>
<li>它是函数表达式</li>
<li>它是定义后立即执行的</li>
</ol>
<p>来看一个例子：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">(<span class="keyword">function</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;I am an IIFE&#x27;</span>);</span><br><span class="line">&#125;)();</span><br></pre></td></tr></table></figure>
<p>将这段代码放在浏览器控制台中执行，会输出<code>I am an IIFE</code>。这就是一个简单的IIFE。</p>
<p>分析一下上面的代码，它分为两部分，每个部分由一组<code>()</code>包裹。<br>第一部分是一个函数(本例用的是匿名函数，也可以是具名函数)：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">(<span class="keyword">function</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;I am an IIFE&#x27;</span>);</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>
<p>第二部分是一个函数调用</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">();</span><br></pre></td></tr></table></figure>
<p>这两部分结合在一起，就形成了一个IIFE。</p>
<h2 id="快速掌握IIFE"><a href="#快速掌握IIFE" class="headerlink" title="快速掌握IIFE"></a>快速掌握IIFE</h2><p>IIFE的语法其实不复杂，但是刚开始要记住它并不容易，这里教大家一个小技巧，可以快速书写IIFE代码。</p>
<ol>
<li>首先，写下两组括弧<code>()()</code></li>
<li>然后在第一组括弧内写下函数定义 - 注意这里必须是匿名函数。</li>
<li>如果函数需要参数，那么在第二组括弧内传入参数。</li>
</ol>
<h3 id="一道练习题，写一个IIFE，计算1-2的和"><a href="#一道练习题，写一个IIFE，计算1-2的和" class="headerlink" title="一道练习题，写一个IIFE，计算1 + 2的和"></a>一道练习题，写一个IIFE，计算1 + 2的和</h3><p>我们使用上面的技巧来书写：</p>
<p>首先写下两组括弧</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">()()</span><br></pre></td></tr></table></figure>
<p>然后在第一组括弧内写下函数定义</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">(<span class="keyword">function</span> <span class="title function_">add</span>(<span class="params">a, b</span>) &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(a + b);</span><br><span class="line">&#125;)()</span><br></pre></td></tr></table></figure>
<p>因为这里的add函数需要参数，所以我们要在第二组括弧内传入参数</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">(<span class="keyword">function</span> <span class="title function_">add</span>(<span class="params">a, b</span>) &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(a + b);</span><br><span class="line">&#125;)(<span class="number">1</span>, <span class="number">2</span>);</span><br></pre></td></tr></table></figure>
<h2 id="IIFE的变种"><a href="#IIFE的变种" class="headerlink" title="IIFE的变种"></a>IIFE的变种</h2><p>上面介绍的IIFE写法是最常见的形式，其实IIFE还有一些其他写法(至于为什么这些写法是可以的，我们下一篇再做介绍)，现罗列如下：</p>
<p>这种写法将调用函数的括号放到了第一组括弧内部。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">(<span class="keyword">function</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;I am an IIFE&#x27;</span>);</span><br><span class="line">&#125;());</span><br></pre></td></tr></table></figure>

<p>以下几种写法都是使用一元运算符来实现的。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">!<span class="keyword">function</span>(<span class="params"></span>) &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;IIFE with !&quot;</span>)</span><br><span class="line">&#125;();</span><br><span class="line"></span><br><span class="line">~<span class="keyword">function</span>(<span class="params"></span>) &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;IIFE with ~&quot;</span>)</span><br><span class="line">&#125;();</span><br><span class="line"></span><br><span class="line">+<span class="keyword">function</span>(<span class="params"></span>) &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;IIFE with +&quot;</span>)</span><br><span class="line">&#125;();</span><br><span class="line"></span><br><span class="line">-<span class="keyword">function</span>(<span class="params"></span>) &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;IIFE with -&quot;</span>)</span><br><span class="line">&#125;();</span><br></pre></td></tr></table></figure>
<p>这些一元运算符的作用是将函数定义转换为一个表达式，从而使其可以被调用。如果不加这些一元运算符的话，就变成了下面的形式：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span>(<span class="params"></span>) &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;IIFE without unary operator&quot;</span>)</span><br><span class="line">&#125;();</span><br></pre></td></tr></table></figure>
<p>这会导致一个语法错误，因为JavaScript引擎会将其解析为一个函数声明，而不是函数表达式。函数声明需要一个函数名，而匿名函数没有名字，所以会报错：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Uncaught SyntaxError: Function statements require a <span class="keyword">function</span> name</span><br></pre></td></tr></table></figure>
<p>我们给它加上一个名字，变成下面这样</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">foo</span>(<span class="params"></span>) &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;IIFE with function name&quot;</span>)</span><br><span class="line">&#125;();</span><br></pre></td></tr></table></figure>
<p>但是还是会报错：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Uncaught SyntaxError: Unexpected token <span class="string">&#x27;)&#x27;</span></span><br></pre></td></tr></table></figure>
<p>javascript引擎会将上述代码解析为一个函数声明和一个分组操作符 - 即<code>()</code>，但是分组操作符内不能是空的，必须有一个表达式，我们在里面加上一个1</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">foo</span>(<span class="params"></span>) &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;IIFE with function name&quot;</span>)</span><br><span class="line">&#125;(<span class="number">1</span>);</span><br></pre></td></tr></table></figure>
<p>这样就不会报错了，但是这不是一个IIFE了。它的返回值就是分组表达式的值，也就是1。</p>
<h2 id="为什么需要IIFE"><a href="#为什么需要IIFE" class="headerlink" title="为什么需要IIFE?"></a>为什么需要IIFE?</h2><p>早期在JavaScript尚未支持模块化的时候，IIFE是实现模块化的一种简单方式，它可以创建一个独立的作用域，从而避免全局污染，下面看一个例子：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> myModule = (<span class="keyword">function</span> <span class="title function_">MyModule</span>(<span class="params"></span>) &#123;</span><br><span class="line">  <span class="keyword">const</span> privateVariable = <span class="string">&#x27;private variable&#x27;</span>;</span><br><span class="line">  <span class="keyword">const</span> publicVariable = <span class="string">&#x27;public variable&#x27;</span>;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">function</span> <span class="title function_">privateMethod</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(privateVariable);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">function</span> <span class="title function_">publicMethod</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(publicVariable);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 将需要暴露给外界的变量和方法写在返回的对象中</span></span><br><span class="line">  <span class="keyword">return</span> &#123;</span><br><span class="line">    publicVariable,</span><br><span class="line">    publicMethod,</span><br><span class="line">  &#125;;</span><br><span class="line">&#125;)();</span><br><span class="line"></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(myModule.<span class="property">publicVariable</span>); <span class="comment">// 访问公共变量</span></span><br><span class="line">myModule.<span class="title function_">publicMethod</span>(); <span class="comment">// 访问公共方法</span></span><br><span class="line"></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(myModule.<span class="property">privateVariable</span>); <span class="comment">// undefined</span></span><br><span class="line">myModule.<span class="title function_">privateMethod</span>(); <span class="comment">// TypeError: myModule.privateMethod is not a function, privateMethod is not accessible</span></span><br></pre></td></tr></table></figure>
<p>分析一下上面的代码，这是一个典型的IIFE + 闭包实现模块化的例子。</p>
<p>MyModule是一个IIFE，它在内部定义了：</p>
<ul>
<li>私有变量<code>privateVariable</code></li>
<li>私有方法<code>privateMethod</code></li>
</ul>
<p>这些变量和方法无法从外部访问。</p>
<p>它还定义了</p>
<ul>
<li>一个公共变量<code>publicVariable</code></li>
<li>一个公共方法<code>publicMethod</code></li>
</ul>
<p>这些可以通过返回的对象访问。</p>
<p>IIFE的返回值赋值给了<code>myModule</code>变量，这样就可以通过<code>myModule</code>访问公共变量和方法。</p>
<p>注意：这个例子仅供参考，在ES6模块已经十分普及的今天，这种方式已经不推荐使用了。</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  


  
  <nav class="pagination">
    <span class="page-number current">1</span><a class="page-number" href="/page/2/">2</a><span class="space">&hellip;</span><a class="page-number" href="/page/35/">35</a><a class="extend next" rel="next" href="/page/2/"><i class="fa fa-angle-right" aria-label="Next page"></i></a>
  </nav>



          </div>
          

<script>
  window.addEventListener('tabs:register', () => {
    let { activeClass } = CONFIG.comments;
    if (CONFIG.comments.storage) {
      activeClass = localStorage.getItem('comments_active') || activeClass;
    }
    if (activeClass) {
      let activeTab = document.querySelector(`a[href="#comment-${activeClass}"]`);
      if (activeTab) {
        activeTab.click();
      }
    }
  });
  if (CONFIG.comments.storage) {
    window.addEventListener('tabs:click', event => {
      if (!event.target.matches('.tabs-comment .tab-content .tab-pane')) return;
      let commentClass = event.target.classList[1];
      localStorage.setItem('comments_active', commentClass);
    });
  }
</script>

        </div>
          
  
  <div class="toggle sidebar-toggle">
    <span class="toggle-line toggle-line-first"></span>
    <span class="toggle-line toggle-line-middle"></span>
    <span class="toggle-line toggle-line-last"></span>
  </div>

  <aside class="sidebar">
    <div class="sidebar-inner">

      <ul class="sidebar-nav motion-element">
        <li class="sidebar-nav-toc">
          Table of Contents
        </li>
        <li class="sidebar-nav-overview">
          Overview
        </li>
      </ul>

      <!--noindex-->
      <div class="post-toc-wrap sidebar-panel">
      </div>
      <!--/noindex-->

      <div class="site-overview-wrap sidebar-panel">
        <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
  <p class="site-author-name" itemprop="name">Philip Zhang</p>
  <div class="site-description" itemprop="description">青春都一餉，忍把浮名換了代碼輕狂。</div>
</div>
<div class="site-state-wrap motion-element">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
          <a href="/archives/">
        
          <span class="site-state-item-count">346</span>
          <span class="site-state-item-name">posts</span>
        </a>
      </div>
      <div class="site-state-item site-state-categories">
            <a href="/categories/">
          
        <span class="site-state-item-count">44</span>
        <span class="site-state-item-name">categories</span></a>
      </div>
      <div class="site-state-item site-state-tags">
            <a href="/tags/">
          
        <span class="site-state-item-count">449</span>
        <span class="site-state-item-name">tags</span></a>
      </div>
  </nav>
</div>



      </div>

    </div>
  </aside>
  <div id="sidebar-dimmer"></div>


      </div>
    </main>

    <footer class="footer">
      <div class="footer-inner">
        

        

<div class="copyright">
  
  &copy; 
  <span itemprop="copyrightYear">2025</span>
  <span class="with-love">
    <i class="fa fa-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">Philip Zhang</span>
    <span class="post-meta-divider">|</span>
    <span class="post-meta-item-icon">
      <i class="fa fa-chart-area"></i>
    </span>
    <span title="Symbols count total">234k</span>
    <span class="post-meta-divider">|</span>
    <span class="post-meta-item-icon">
      <i class="fa fa-coffee"></i>
    </span>
    <span title="Reading time total">14:12</span>
</div>
  <div class="powered-by">Powered by <a href="https://hexo.io/" class="theme-link" rel="noopener" target="_blank">Hexo</a> & <a href="https://theme-next.org/" class="theme-link" rel="noopener" target="_blank">NexT.Gemini</a>
  </div>

        








      </div>
    </footer>
  </div>

  
  <script src="/lib/anime.min.js"></script>
  <script src="/lib/velocity/velocity.min.js"></script>
  <script src="/lib/velocity/velocity.ui.min.js"></script>

<script src="/js/utils.js"></script>

<script src="/js/motion.js"></script>


<script src="/js/schemes/pisces.js"></script>


<script src="/js/next-boot.js"></script>




  




  
<script src="/js/local-search.js"></script>













  

  

  <!-- Google tag (gtag.js) -->
<script async src="https://www.googletagmanager.com/gtag/js?id=G-MRKXK1S1GG"></script>
<script>
  window.dataLayer = window.dataLayer || [];
  function gtag(){dataLayer.push(arguments);}
  gtag('js', new Date());

  gtag('config', 'G-MRKXK1S1GG');
</script>
</body>
</html>
