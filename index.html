<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=2">
<meta name="theme-color" content="#222">
<meta name="generator" content="Hexo 7.3.0">
<meta name="google-site-verification" content="WoeYixr9--6ikwIZxHiYjVfhk2UpqldMqWnPGdyKfBw" />
  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png">
  <link rel="mask-icon" href="/images/logo.svg" color="#222">

<link rel="stylesheet" href="/css/main.css">


<link rel="stylesheet" href="/lib/font-awesome/css/all.min.css">

<script id="hexo-configurations">
    var NexT = window.NexT || {};
    var CONFIG = {"hostname":"frontendthink.com","root":"/","scheme":"Gemini","version":"7.8.0","exturl":false,"sidebar":{"position":"left","display":"post","padding":18,"offset":12,"onmobile":false},"copycode":{"enable":false,"show_result":false,"style":null},"back2top":{"enable":true,"sidebar":false,"scrollpercent":false},"bookmark":{"enable":false,"color":"#222","save":"auto"},"fancybox":false,"mediumzoom":false,"lazyload":false,"pangu":false,"comments":{"style":"tabs","active":null,"storage":true,"lazyload":false,"nav":null},"algolia":{"hits":{"per_page":10},"labels":{"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}},"localsearch":{"enable":true,"trigger":"auto","top_n_per_article":1,"unescape":false,"preload":false},"motion":{"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}},"path":"search.xml"};
  </script>

  <meta name="description" content="青春都一餉，忍把浮名換了代碼輕狂。">
<meta property="og:type" content="website">
<meta property="og:title" content="Philip">
<meta property="og:url" content="https://frontendthink.com/index.html">
<meta property="og:site_name" content="Philip">
<meta property="og:description" content="青春都一餉，忍把浮名換了代碼輕狂。">
<meta property="og:locale" content="en_US">
<meta property="article:author" content="Philip Zhang">
<meta name="twitter:card" content="summary">

<link rel="canonical" href="https://frontendthink.com/">


<script id="page-configurations">
  // https://hexo.io/docs/variables.html
  CONFIG.page = {
    sidebar: "",
    isHome : true,
    isPost : false,
    lang   : 'en'
  };
</script>

  <title>Philip</title>
  






  <noscript>
  <style>
  .use-motion .brand,
  .use-motion .menu-item,
  .sidebar-inner,
  .use-motion .post-block,
  .use-motion .pagination,
  .use-motion .comments,
  .use-motion .post-header,
  .use-motion .post-body,
  .use-motion .collection-header { opacity: initial; }

  .use-motion .site-title,
  .use-motion .site-subtitle {
    opacity: initial;
    top: initial;
  }

  .use-motion .logo-line-before i { left: initial; }
  .use-motion .logo-line-after i { right: initial; }
  </style>
</noscript>

</head>

<body itemscope itemtype="http://schema.org/WebPage">
  <div class="container use-motion">
    <div class="headband"></div>

    <header class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-container">
  <div class="site-nav-toggle">
    <div class="toggle" aria-label="Toggle navigation bar">
      <span class="toggle-line toggle-line-first"></span>
      <span class="toggle-line toggle-line-middle"></span>
      <span class="toggle-line toggle-line-last"></span>
    </div>
  </div>

  <div class="site-meta">

    <a href="/" class="brand" rel="start">
      <span class="logo-line-before"><i></i></span>
      <h1 class="site-title">Philip</h1>
      <span class="logo-line-after"><i></i></span>
    </a>
      <p class="site-subtitle" itemprop="description">Philip's blog</p>
  </div>

  <div class="site-nav-right">
    <div class="toggle popup-trigger">
        <i class="fa fa-search fa-fw fa-lg"></i>
    </div>
  </div>
</div>




<nav class="site-nav">
  <ul id="menu" class="main-menu menu">
        <li class="menu-item menu-item-home">

    <a href="/" rel="section"><i class="fa fa-home fa-fw"></i>Home</a>

  </li>
        <li class="menu-item menu-item-tags">

    <a href="/tags/" rel="section"><i class="fa fa-tags fa-fw"></i>Tags</a>

  </li>
        <li class="menu-item menu-item-categories">

    <a href="/categories/" rel="section"><i class="fa fa-th fa-fw"></i>Categories</a>

  </li>
        <li class="menu-item menu-item-archives">

    <a href="/archives/" rel="section"><i class="fa fa-archive fa-fw"></i>Archives</a>

  </li>
      <li class="menu-item menu-item-search">
        <a role="button" class="popup-trigger"><i class="fa fa-search fa-fw"></i>Search
        </a>
      </li>
  </ul>
</nav>



  <div class="search-pop-overlay">
    <div class="popup search-popup">
        <div class="search-header">
  <span class="search-icon">
    <i class="fa fa-search"></i>
  </span>
  <div class="search-input-container">
    <input autocomplete="off" autocapitalize="off"
           placeholder="Searching..." spellcheck="false"
           type="search" class="search-input">
  </div>
  <span class="popup-btn-close">
    <i class="fa fa-times-circle"></i>
  </span>
</div>
<div id="search-result">
  <div id="no-result">
    <i class="fa fa-spinner fa-pulse fa-5x fa-fw"></i>
  </div>
</div>

    </div>
  </div>

</div>
    </header>

    
  <div class="back-to-top">
    <i class="fa fa-arrow-up"></i>
    <span>0%</span>
  </div>


    <main class="main">
      <div class="main-inner">
        <div class="content-wrap">
          

          <div class="content index posts-expand">
            
      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="en">
    <link itemprop="mainEntityOfPage" href="https://frontendthink.com/2025/07/13/typescript-use-const-instead-of-enum/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="Philip Zhang">
      <meta itemprop="description" content="青春都一餉，忍把浮名換了代碼輕狂。">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Philip">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2025/07/13/typescript-use-const-instead-of-enum/" class="post-title-link" itemprop="url">typescript-use-const-instead-of-enum</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>
              

              <time title="Created: 2025-07-13 12:03:04 / Modified: 12:53:56" itemprop="dateCreated datePublished" datetime="2025-07-13T12:03:04+08:00">2025-07-13</time>
            </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">In</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/typescript/" itemprop="url" rel="index"><span itemprop="name">typescript</span></a>
                </span>
            </span>

          <br>
            <span class="post-meta-item" title="Symbols count in article">
              <span class="post-meta-item-icon">
                <i class="far fa-file-word"></i>
              </span>
                <span class="post-meta-item-text">Symbols count in article: </span>
              <span>1k</span>
            </span>
            <span class="post-meta-item" title="Reading time">
              <span class="post-meta-item-icon">
                <i class="far fa-clock"></i>
              </span>
                <span class="post-meta-item-text">Reading time &asymp;</span>
              <span>4 mins.</span>
            </span>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h2 id="介绍"><a href="#介绍" class="headerlink" title="介绍"></a>介绍</h2><p>在昨天的文章中，我们介绍了如何使用<code>typescript</code>中的枚举类型<code>Enum</code>来处理状态值。今天，我们将探讨一个更好的实践：使用<code>const</code>代替枚举。为什么说<code>const</code>是更好的方案呢，因为typeScript中的枚举类型有一些弊端。</p>
<h2 id="枚举类型的弊端"><a href="#枚举类型的弊端" class="headerlink" title="枚举类型的弊端"></a>枚举类型的弊端</h2><h3 id="枚举类型无法实现真正的类型安全"><a href="#枚举类型无法实现真正的类型安全" class="headerlink" title="枚举类型无法实现真正的类型安全"></a>枚举类型无法实现真正的类型安全</h3><p>对于数字类型的枚举，无法实现真正的类型安全，比如下面的枚举类型定义：</p>
<figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">enum</span> <span class="title class_">JobStatus</span> &#123;</span><br><span class="line">  <span class="variable constant_">PENDING</span> = <span class="number">1</span>,</span><br><span class="line">  <span class="variable constant_">RUNNING</span> = <span class="number">2</span>，</span><br><span class="line">  <span class="variable constant_">SUCCESS</span> = <span class="number">3</span>,</span><br><span class="line">  <span class="variable constant_">FAILED</span> = <span class="number">4</span>,</span><br><span class="line">  <span class="variable constant_">CANCELED</span> = <span class="number">5</span>,</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这里面定义了五种类型的状态，分别用数字1到5来表示。但是这里有一个隐藏的问题，你可以将任意数字赋值给<code>JobStatus</code>类型的变量，而不管这个数字是否在1到5之间。例如：</p>
<figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> <span class="attr">status</span>: <span class="title class_">JobStatus</span> = <span class="number">1</span>; <span class="comment">// 这是合法的</span></span><br><span class="line">status = <span class="number">6</span>; <span class="comment">// 这也是合法的，虽然6不是枚举定义的</span></span><br></pre></td></tr></table></figure>
<p>这就导致了类型安全性的问题，枚举类型并不能限制状态值只能是1到5之间的数字。</p>
<p>一个更好的做法是使用字符串类型代替数字类型：</p>
<figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="keyword">enum</span> <span class="title class_">JobStatus</span> &#123;</span><br><span class="line">  <span class="variable constant_">PENDING</span> = <span class="string">&#x27;PENDING&#x27;</span>,</span><br><span class="line">  <span class="variable constant_">RUNNING</span> = <span class="string">&#x27;RUNNING&#x27;</span>,</span><br><span class="line">  <span class="variable constant_">SUCCESS</span> = <span class="string">&#x27;SUCCESS&#x27;</span>,</span><br><span class="line">  <span class="variable constant_">FAILED</span> = <span class="string">&#x27;FAILED&#x27;</span>,</span><br><span class="line">  <span class="variable constant_">CANCELED</span> = <span class="string">&#x27;CANCELED&#x27;</span>,</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这样就可以确保状态值只能是枚举定义的字符串，而不能是其他任意字符串。</p>
<figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="attr">status</span>: <span class="title class_">JobStatus</span> = <span class="title class_">JobStatus</span>.<span class="property">PENDING</span>; <span class="comment">// 这是合法的</span></span><br><span class="line"><span class="keyword">const</span> <span class="attr">status</span>: <span class="title class_">JobStatus</span> = <span class="string">&#x27;INVALID&#x27;</span>; <span class="comment">// 这将导致编译错误</span></span><br></pre></td></tr></table></figure>

<h3 id="枚举类型不支持Tree-Shaking"><a href="#枚举类型不支持Tree-Shaking" class="headerlink" title="枚举类型不支持Tree-Shaking"></a>枚举类型不支持Tree-Shaking</h3><p><code>Tree-Shaking</code>是指在打包时去除未使用的代码。TypeScript的枚举类型在编译后会生成一个对象，这个对象包含了所有枚举成员的映射关系。即使程序中没有使用这个枚举类型，编译后的代码中仍然会保留这个对象。这会导致打包后的代码体积增大。</p>
<h2 id="使用const代替枚举"><a href="#使用const代替枚举" class="headerlink" title="使用const代替枚举"></a>使用<code>const</code>代替枚举</h2><p>上面提到的两点问题，使用<code>const</code>可以很好地解决。下面使用<code>const</code>来实现同样的功能，首先定义Job状态常量，因为要兼顾后端接口的整数类型和前端显示的字符串类型，我们索性将其封装到一起。用<code>code</code>表示状态值，用<code>label</code>表示状态的显示名称。</p>
<figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="title class_">JobStatus</span> = &#123;</span><br><span class="line">  <span class="attr">PENDING</span>: &#123;<span class="attr">code</span>: <span class="number">1</span>, <span class="attr">label</span>: <span class="string">&#x27;PENDING&#x27;</span>&#125;,</span><br><span class="line">  <span class="attr">RUNNING</span>: &#123;<span class="attr">code</span>: <span class="number">2</span>, <span class="attr">label</span>: <span class="string">&#x27;RUNNING&#x27;</span>&#125;,</span><br><span class="line">  <span class="attr">SUCCESS</span>: &#123;<span class="attr">code</span>: <span class="number">3</span>, <span class="attr">label</span>: <span class="string">&#x27;SUCCESS&#x27;</span>&#125;,</span><br><span class="line">  <span class="attr">FAILED</span>: &#123;<span class="attr">code</span>: <span class="number">4</span>, <span class="attr">label</span>: <span class="string">&#x27;FAILED&#x27;</span>&#125;,</span><br><span class="line">  <span class="attr">CANCELED</span>: &#123;<span class="attr">code</span>: <span class="number">5</span>, <span class="attr">label</span>: <span class="string">&#x27;CANCELED&#x27;</span>&#125;,</span><br><span class="line">&#125; <span class="keyword">as</span> <span class="keyword">const</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> <span class="title class_">JobStatusType</span> = <span class="keyword">typeof</span> <span class="title class_">JobStatus</span>[keyof <span class="keyword">typeof</span> <span class="title class_">JobStatus</span>];</span><br></pre></td></tr></table></figure>
<p>接下来定义Job接口，使用<code>JobStatusType</code>来描述状态类型。</p>
<figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">interface</span> <span class="title class_">Job</span> &#123;</span><br><span class="line">  <span class="attr">id</span>: <span class="built_in">string</span>;</span><br><span class="line">  <span class="attr">name</span>: <span class="built_in">string</span>;</span><br><span class="line">  <span class="attr">status</span>: <span class="title class_">JobStatusType</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>后端返回的数据和先前一样用数字类型来表示Job状态。</p>
<figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> jobs = [</span><br><span class="line">  &#123; <span class="attr">id</span>: <span class="string">&#x27;1&#x27;</span>, <span class="attr">name</span>: <span class="string">&#x27;Job 1&#x27;</span>, <span class="attr">status</span>: <span class="number">1</span> &#125;,</span><br><span class="line">  &#123; <span class="attr">id</span>: <span class="string">&#x27;2&#x27;</span>, <span class="attr">name</span>: <span class="string">&#x27;Job 2&#x27;</span>, <span class="attr">status</span>: <span class="number">2</span> &#125;,</span><br><span class="line">  &#123; <span class="attr">id</span>: <span class="string">&#x27;3&#x27;</span>, <span class="attr">name</span>: <span class="string">&#x27;Job 3&#x27;</span>, <span class="attr">status</span>: <span class="number">3</span> &#125;,</span><br><span class="line">  &#123; <span class="attr">id</span>: <span class="string">&#x27;4&#x27;</span>, <span class="attr">name</span>: <span class="string">&#x27;Job 4&#x27;</span>, <span class="attr">status</span>: <span class="number">4</span> &#125;,</span><br><span class="line">  &#123; <span class="attr">id</span>: <span class="string">&#x27;5&#x27;</span>, <span class="attr">name</span>: <span class="string">&#x27;Job 5&#x27;</span>, <span class="attr">status</span>: <span class="number">5</span> &#125;,</span><br><span class="line">];</span><br></pre></td></tr></table></figure>

<p>最后是打印Job的函数，这里涉及到一个问题，我们不能像之前一样直接使用字符串来访问状态的显示名称，因为现在状态是一个对象，我们需要通过状态的<code>code</code>来获取对应的<code>label</code>。</p>
<figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">printJobStatus</span>(<span class="params"><span class="attr">job</span>: <span class="title class_">Job</span></span>) &#123;</span><br><span class="line">  <span class="keyword">const</span> status = <span class="title class_">Object</span>.<span class="title function_">values</span>(<span class="title class_">JobStatus</span>).<span class="title function_">find</span>(<span class="function"><span class="params">s</span> =&gt;</span> s.<span class="property">code</span> === job.<span class="property">status</span>);</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">`Job <span class="subst">$&#123;job.id&#125;</span> (<span class="subst">$&#123;job.name&#125;</span>) is currently <span class="subst">$&#123;status?.label ?? <span class="string">&#x27;UNKNOWN&#x27;</span>&#125;</span>.`</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>现在我们可以调用这个函数来打印Job的状态：</p>
<figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">jobs.<span class="title function_">forEach</span>(printJobStatus);</span><br></pre></td></tr></table></figure>
<p>这样做的好处是可以省去之前的映射函数<code>getJobDisplayName</code>，因为我们在定义JobStatus时已经将状态码(code)和显示名称(label)封装在一起了。</p>
<figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 该函数可以省略</span></span><br><span class="line"><span class="keyword">const</span> <span class="attr">getJobDisplayName</span>: <span class="title class_">Record</span>&lt;<span class="title class_">JobStatus</span>, <span class="built_in">string</span>&gt; = &#123;</span><br><span class="line">  [<span class="title class_">JobStatus</span>.<span class="property">PENDING</span>]: <span class="string">&#x27;Pending&#x27;</span>,</span><br><span class="line">  [<span class="title class_">JobStatus</span>.<span class="property">RUNNING</span>]: <span class="string">&#x27;In progress&#x27;</span>,</span><br><span class="line">  [<span class="title class_">JobStatus</span>.<span class="property">SUCCESS</span>]: <span class="string">&#x27;Success&#x27;</span>,</span><br><span class="line">  [<span class="title class_">JobStatus</span>.<span class="property">FAILED</span>]: <span class="string">&#x27;Failed&#x27;</span>,</span><br><span class="line">  [<span class="title class_">JobStatus</span>.<span class="property">CANCELED</span>]: <span class="string">&#x27;Canceled&#x27;</span>,</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>弊端是多了一个查找的过程，但这个查找过程是非常轻量级的，因为我们只需要遍历一次<code>JobStatus</code>对象来找到对应的状态。</p>
<p><code>const</code>代替枚举的好处在于：</p>
<ol>
<li><strong>类型安全</strong>：使用<code>const</code>可以确保状态值只能是预定义的状态，而不能是其他任意值。</li>
<li><strong>Tree-Shaking</strong>：<code>const</code>支持Tree-Shaking，只有实际使用才会被保留，从而减小打包后的代码体积。</li>
</ol>
<p>好了，今天就到这里了，我们明天见。</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="en">
    <link itemprop="mainEntityOfPage" href="https://frontendthink.com/2025/07/12/typescript-enum-best-practice/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="Philip Zhang">
      <meta itemprop="description" content="青春都一餉，忍把浮名換了代碼輕狂。">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Philip">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2025/07/12/typescript-enum-best-practice/" class="post-title-link" itemprop="url">typescript-enum-best-practice</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>

              <time title="Created: 2025-07-12 11:35:11" itemprop="dateCreated datePublished" datetime="2025-07-12T11:35:11+08:00">2025-07-12</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">Edited on</span>
                <time title="Modified: 2025-07-13 10:26:11" itemprop="dateModified" datetime="2025-07-13T10:26:11+08:00">2025-07-13</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">In</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/typescript/" itemprop="url" rel="index"><span itemprop="name">typescript</span></a>
                </span>
            </span>

          <br>
            <span class="post-meta-item" title="Symbols count in article">
              <span class="post-meta-item-icon">
                <i class="far fa-file-word"></i>
              </span>
                <span class="post-meta-item-text">Symbols count in article: </span>
              <span>1.2k</span>
            </span>
            <span class="post-meta-item" title="Reading time">
              <span class="post-meta-item-icon">
                <i class="far fa-clock"></i>
              </span>
                <span class="post-meta-item-text">Reading time &asymp;</span>
              <span>4 mins.</span>
            </span>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h2 id="介绍"><a href="#介绍" class="headerlink" title="介绍"></a>介绍</h2><p>这篇文章来谈一下 TypeScript 中的枚举类型（Enum）以及一些最佳实践。事情的起因是这样的，今天看到自己之前写的一段代码，感觉不是很好，于是想优化一下，期间用到了枚举类型，遂记录一下。为了方便理解，我将原来的例子简化一下。</p>
<h2 id="业务需求"><a href="#业务需求" class="headerlink" title="业务需求"></a>业务需求</h2><p>业务需求是这样的：我们要实现一个Job系统，你可以将其想象为Jenkins Job类似的东西，每个Job有一个状态，状态可以是以下几种：</p>
<ul>
<li><code>PENDING</code>：等待执行</li>
<li><code>RUNNING</code>：正在执行</li>
<li><code>SUCCESS</code>：执行成功</li>
<li><code>FAILED</code>：执行失败</li>
<li><code>CANCELED</code>：执行被取消</li>
<li></li>
</ul>
<p>Job的状态信息由后端返回，前端只负责展示，也不需要实时刷新。很简单的需求，对吧？我的原始代码如下：</p>
<h2 id="原始代码"><a href="#原始代码" class="headerlink" title="原始代码"></a>原始代码</h2><p>前端数据类型定义， 首先定义一个字面量用来保存Job状态，然后定义一个Job接口来描述Job对象。</p>
<figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 定义Job状态字面量</span></span><br><span class="line"><span class="keyword">type</span> <span class="title class_">JobStatus</span> = <span class="string">&#x27;PENDING&#x27;</span> | <span class="string">&#x27;RUNNING&#x27;</span> | <span class="string">&#x27;SUCCESS&#x27;</span> | <span class="string">&#x27;FAILED&#x27;</span> | <span class="string">&#x27;CANCELED&#x27;</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 每个Job包含id、name和status三个属性</span></span><br><span class="line"><span class="keyword">interface</span> <span class="title class_">Job</span> &#123;</span><br><span class="line">  <span class="attr">id</span>: <span class="built_in">string</span>;</span><br><span class="line">  <span class="attr">name</span>: <span class="built_in">string</span>;</span><br><span class="line">  <span class="attr">status</span>: <span class="title class_">JobStatus</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>后端返回数据如下，可以看到后端是用数字类型来表示状态的。</p>
<figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> jobData = [</span><br><span class="line">  &#123; <span class="attr">id</span>: <span class="string">&#x27;1&#x27;</span>, <span class="attr">name</span>: <span class="string">&#x27;Job 1&#x27;</span>, <span class="attr">status</span>: <span class="number">1</span> &#125;, <span class="comment">// PENDING</span></span><br><span class="line">  &#123; <span class="attr">id</span>: <span class="string">&#x27;2&#x27;</span>, <span class="attr">name</span>: <span class="string">&#x27;Job 2&#x27;</span>, <span class="attr">status</span>: <span class="number">2</span> &#125;, <span class="comment">// RUNNING</span></span><br><span class="line">  &#123; <span class="attr">id</span>: <span class="string">&#x27;3&#x27;</span>, <span class="attr">name</span>: <span class="string">&#x27;Job 3&#x27;</span>, <span class="attr">status</span>: <span class="number">3</span> &#125;, <span class="comment">// SUCCESS</span></span><br><span class="line">  &#123; <span class="attr">id</span>: <span class="string">&#x27;4&#x27;</span>, <span class="attr">name</span>: <span class="string">&#x27;Job 4&#x27;</span>, <span class="attr">status</span>: <span class="number">4</span> &#125;, <span class="comment">// FAILED</span></span><br><span class="line">  &#123; <span class="attr">id</span>: <span class="string">&#x27;5&#x27;</span>, <span class="attr">name</span>: <span class="string">&#x27;Job 5&#x27;</span>, <span class="attr">status</span>: <span class="number">5</span> &#125;, <span class="comment">// CANCELED</span></span><br><span class="line">];</span><br></pre></td></tr></table></figure>

<p>为了将后端返回的数字类型和前端定义的Job Status对应起来，我又额外写了一个映射函数：</p>
<figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">mapJobStatus</span>(<span class="params"><span class="attr">status</span>: <span class="built_in">number</span></span>): <span class="title class_">JobStatus</span> &#123;</span><br><span class="line">  <span class="keyword">switch</span> (status) &#123;</span><br><span class="line">    <span class="keyword">case</span> <span class="number">1</span>:</span><br><span class="line">      <span class="keyword">return</span> <span class="string">&#x27;PENDING&#x27;</span>;</span><br><span class="line">    <span class="keyword">case</span> <span class="number">2</span>:</span><br><span class="line">      <span class="keyword">return</span> <span class="string">&#x27;RUNNING&#x27;</span>;</span><br><span class="line">    <span class="keyword">case</span> <span class="number">3</span>:</span><br><span class="line">      <span class="keyword">return</span> <span class="string">&#x27;SUCCESS&#x27;</span>;</span><br><span class="line">    <span class="keyword">case</span> <span class="number">4</span>:</span><br><span class="line">      <span class="keyword">return</span> <span class="string">&#x27;FAILED&#x27;</span>;</span><br><span class="line">    <span class="keyword">case</span> <span class="number">5</span>:</span><br><span class="line">      <span class="keyword">return</span> <span class="string">&#x27;CANCELED&#x27;</span>;</span><br><span class="line">    <span class="attr">default</span>:</span><br><span class="line">      <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">Error</span>(<span class="string">`Unknown status: <span class="subst">$&#123;status&#125;</span>`</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>接下来就是展示了，展示Job状态时，用户不想看到全大写的状态，而是想看到首字母大写的状态，所以我又写了一个函数来处理这个问题：</p>
<figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">getJobDisplayName</span>(<span class="params"><span class="attr">status</span>: <span class="title class_">JobStatus</span></span>): <span class="built_in">string</span> &#123;</span><br><span class="line">  <span class="keyword">return</span> status.<span class="title function_">charAt</span>(<span class="number">0</span>).<span class="title function_">toUpperCase</span>() + status.<span class="title function_">slice</span>(<span class="number">1</span>).<span class="title function_">toLowerCase</span>();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 转换后的状态字符串如下：</span></span><br><span class="line"><span class="comment">PENDING -&gt; Pending</span></span><br><span class="line"><span class="comment">RUNNING -&gt; Running</span></span><br><span class="line"><span class="comment">SUCCESS -&gt; Success</span></span><br><span class="line"><span class="comment">FAILED -&gt; Failed</span></span><br><span class="line"><span class="comment">CANCELED -&gt; Canceled</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure>
<p>好了，下面我们停下来思考一下，以上这些代码都解决了哪些问题，为什么需要两个转换函数，有没有更好的解决方式？</p>
<h2 id="问题分析"><a href="#问题分析" class="headerlink" title="问题分析"></a>问题分析</h2><p>为了完成这个需求，上述代码做了以下几件事：</p>
<ol>
<li>后端状态码到前端状态的转换（1,2,3,4,5 -&gt; PENDING, RUNNING, SUCCESS, FAILED, CANCELED）</li>
<li>前端状态字面量到展示字符串的转换（PENDING, RUNNING, SUCCESS, FAILED, CANCELED -&gt; Pending, Running, Success, Failed, Canceled）</li>
</ol>
<p>对于第一点，可以使用枚举类型来实现，这样就不需要手动维护状态码和状态字面量之间的映射关系了。</p>
<p>对于第二点，原本的实现是将全大写的状态转换为首字母大写的形式，这种转换方式比较简单，但实际业务中，可能会有更复杂的需求，比如用户希望看到不同的展示字符串（例如将<code>RUNNING</code>显示为<code>In progress</code>）。因此，使用一个映射表来处理这种转换会更加灵活。</p>
<h2 id="优化后的代码"><a href="#优化后的代码" class="headerlink" title="优化后的代码"></a>优化后的代码</h2><p>我们可以使用 TypeScript 的枚举类型来简化代码。首先定义一个枚举来表示 Job 状态：</p>
<figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">enum</span> <span class="title class_">JobStatus</span> &#123;</span><br><span class="line">  <span class="variable constant_">PENDING</span> = <span class="number">1</span>,</span><br><span class="line">  <span class="variable constant_">RUNNING</span> = <span class="number">2</span>,</span><br><span class="line">  <span class="variable constant_">SUCCESS</span> = <span class="number">3</span>,</span><br><span class="line">  <span class="variable constant_">FAILED</span> = <span class="number">4</span>,</span><br><span class="line">  <span class="variable constant_">CANCELED</span> = <span class="number">5</span>,</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这样就可以省去第一个转换函数<code>mapJobStatus</code>，因为枚举本身就提供了状态码到状态字面量的映射，可以直接使用这个枚举来定义 Job 接口：</p>
<figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">interface</span> <span class="title class_">Job</span> &#123;</span><br><span class="line">  <span class="attr">id</span>: <span class="built_in">string</span>;</span><br><span class="line">  <span class="attr">name</span>: <span class="built_in">string</span>;</span><br><span class="line">  <span class="attr">status</span>: <span class="title class_">JobStatus</span>; <span class="comment">// 使用枚举类型</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>接下来，重写<code>getJobDisplayName</code>, 这里使用typescript的<code>Record</code>类型来创建一个映射表（<code>Record</code>类型相当于一个键值对的映射，只不过键和值都是类型化的），将枚举值映射到展示字符串，与原本的实现方式相比，这种方式更加简洁易维护。</p>
<figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="attr">getJobDisplayName</span>: <span class="title class_">Record</span>&lt;<span class="title class_">JobStatus</span>, <span class="built_in">string</span>&gt; = &#123;</span><br><span class="line">  [<span class="title class_">JobStatus</span>.<span class="property">PENDING</span>]: <span class="string">&#x27;Pending&#x27;</span>,</span><br><span class="line">  [<span class="title class_">JobStatus</span>.<span class="property">RUNNING</span>]: <span class="string">&#x27;In progress&#x27;</span>,</span><br><span class="line">  [<span class="title class_">JobStatus</span>.<span class="property">SUCCESS</span>]: <span class="string">&#x27;Success&#x27;</span>,</span><br><span class="line">  [<span class="title class_">JobStatus</span>.<span class="property">FAILED</span>]: <span class="string">&#x27;Failed&#x27;</span>,</span><br><span class="line">  [<span class="title class_">JobStatus</span>.<span class="property">CANCELED</span>]: <span class="string">&#x27;Canceled&#x27;</span>,</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>最后是调用代码，如下：</p>
<figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> jobs = [</span><br><span class="line">  &#123; <span class="attr">id</span>: <span class="string">&#x27;1&#x27;</span>, <span class="attr">name</span>: <span class="string">&#x27;Job 1&#x27;</span>, <span class="attr">status</span>: <span class="number">1</span> &#125;,</span><br><span class="line">  &#123; <span class="attr">id</span>: <span class="string">&#x27;2&#x27;</span>, <span class="attr">name</span>: <span class="string">&#x27;Job 2&#x27;</span>, <span class="attr">status</span>: <span class="number">2</span> &#125;,</span><br><span class="line">  &#123; <span class="attr">id</span>: <span class="string">&#x27;3&#x27;</span>, <span class="attr">name</span>: <span class="string">&#x27;Job 3&#x27;</span>, <span class="attr">status</span>: <span class="number">3</span> &#125;,</span><br><span class="line">  &#123; <span class="attr">id</span>: <span class="string">&#x27;4&#x27;</span>, <span class="attr">name</span>: <span class="string">&#x27;Job 4&#x27;</span>, <span class="attr">status</span>: <span class="number">4</span> &#125;,</span><br><span class="line">  &#123; <span class="attr">id</span>: <span class="string">&#x27;5&#x27;</span>, <span class="attr">name</span>: <span class="string">&#x27;Job 5&#x27;</span>, <span class="attr">status</span>: <span class="number">5</span> &#125;,</span><br><span class="line">];</span><br><span class="line"></span><br><span class="line">jobs.<span class="title function_">forEach</span>(<span class="function">(<span class="params">job</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(</span><br><span class="line">    <span class="string">`Job ID: <span class="subst">$&#123;job.id&#125;</span>, Name: <span class="subst">$&#123;job.name&#125;</span>, Status: <span class="subst">$&#123;</span></span></span><br><span class="line"><span class="subst"><span class="string">      getJobDisplayName[job.status <span class="keyword">as</span> JobStatus]</span></span></span><br><span class="line"><span class="subst"><span class="string">    &#125;</span>`</span></span><br><span class="line">  );</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>
<p>使用枚举类型的好处是：</p>
<ol>
<li><strong>可读性</strong>：枚举提供了更清晰的语义，</li>
<li><strong>类型安全</strong>：TypeScript 的枚举类型可以确保状态值的合法性，避免了手动维护映射关系的错误。</li>
<li><strong>简化代码</strong>：减少了转换函数的数量，使代码更简洁</li>
<li><strong>易于维护</strong>：如果需要添加新的状态，只需在枚举中添加即可，不需要修改多个地方。</li>
</ol>
<p>有没有更好的实现方式？很想听听大家的想法，欢迎留言讨论。</p>
<p>今天就到这里了，我们明天见。</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="en">
    <link itemprop="mainEntityOfPage" href="https://frontendthink.com/2025/07/12/javascript-operator-add/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="Philip Zhang">
      <meta itemprop="description" content="青春都一餉，忍把浮名換了代碼輕狂。">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Philip">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2025/07/12/javascript-operator-add/" class="post-title-link" itemprop="url">javascript-operator-add</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>

              <time title="Created: 2025-07-12 07:24:56" itemprop="dateCreated datePublished" datetime="2025-07-12T07:24:56+08:00">2025-07-12</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">Edited on</span>
                <time title="Modified: 2025-07-13 08:30:55" itemprop="dateModified" datetime="2025-07-13T08:30:55+08:00">2025-07-13</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">In</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/javascript/" itemprop="url" rel="index"><span itemprop="name">javascript</span></a>
                </span>
            </span>

          <br>
            <span class="post-meta-item" title="Symbols count in article">
              <span class="post-meta-item-icon">
                <i class="far fa-file-word"></i>
              </span>
                <span class="post-meta-item-text">Symbols count in article: </span>
              <span>1.3k</span>
            </span>
            <span class="post-meta-item" title="Reading time">
              <span class="post-meta-item-icon">
                <i class="far fa-clock"></i>
              </span>
                <span class="post-meta-item-text">Reading time &asymp;</span>
              <span>5 mins.</span>
            </span>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h2 id="介绍"><a href="#介绍" class="headerlink" title="介绍"></a>介绍</h2><p>昨天在网上看到一道面试题，是关于JavaScript中的<code>+</code>元算符的，如下：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">[] + <span class="number">0</span> = ?</span><br><span class="line">&#123;&#125; + <span class="number">0</span> = ?</span><br></pre></td></tr></table></figure>
<p>要解决这道题，我们首先要了解JavaScript中<code>+</code>运算符的行为，<code>+</code>元算符在JavaScript中主要有三种用途：一是用于数字相加，二是用于字符串连接，三是用于类型转换。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">1</span> + <span class="number">2</span> = <span class="number">3</span> <span class="comment">// 数字相加</span></span><br><span class="line"><span class="string">&#x27;Hello, &#x27;</span> + <span class="string">&#x27;World!&#x27;</span> = <span class="string">&#x27;Hello, World!&#x27;</span> <span class="comment">// 字符串连接</span></span><br><span class="line">+<span class="string">&#x27;1&#x27;</span> = <span class="number">1</span> <span class="comment">// 字符串转换为数字</span></span><br></pre></td></tr></table></figure>
<p>再回到面试题，可以看出，这并非常规的加法操作，因为运算符两侧的操作数并非都是数字类型，而是包含了数组和对象。难道是字符串连接吗？不确定，是类型转换？好像也不是。</p>
<p>追本溯源，我们先看看MDN上关于<code>+</code>的运行规则吧：</p>
<p>如果<code>+</code>元算符的操作数包含非基本类型（比如对象，数组等），先将其转换为基本类型(primitive type)。</p>
<blockquote>
<p>在JavaScript中，基本类型包括<code>undefined</code>、<code>null</code>、<code>boolean</code>、<code>number</code>、<code>string</code>、<code>BigInt</code>、<code>Symbol</code>。</p>
</blockquote>
<p>当<code>+</code>元算符两侧都是基本类型时，执行规则如下：</p>
<ol>
<li>有一个操作数是字符串时，将另一个操作数也转换为字符串，并执行字符串连接；</li>
<li>有一个操作数是<code>BigInt</code>时，将另一个操作数也转换为<code>BigInt</code>，并执行加法；</li>
<li>否则，将两个操作数都转换为数字，并执行加法。</li>
</ol>
<p>举几个列子：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">1</span> + <span class="string">`2`</span> = <span class="string">&#x27;12&#x27;</span> <span class="comment">// 满足规则1，将数字1转换为字符串&#x27;1&#x27;，执行字符串连接</span></span><br><span class="line"><span class="number">1</span> + <span class="number">2n</span> = <span class="number">3n</span> <span class="comment">// 满足规则2，将数字1转换为</span></span><br><span class="line"><span class="literal">null</span> + <span class="literal">true</span> = <span class="number">1</span> <span class="comment">// 满足规则3，将null转换为数字0，将true转换为数字1，执行加法</span></span><br></pre></td></tr></table></figure>

<p>注意以上3条规则是按顺序执行的，字符串连接的优先级高于数字加法，所以字符串和数字相加时，永远会转换为字符串连接。</p>
<p>现在来看<code>[] + 0</code>该如何执行，首先<code>[]</code>是数组，不属于基本类型，所以先将它转换为基本类型，对象类型转换为基本类型的操作如下：</p>
<ol>
<li>调用对象的<code>toPrimitive</code>方法；</li>
<li>如果没有<code>toPrimitive</code>方法，则调用<code>valueOf</code>方法；</li>
<li>如果<code>valueOf</code>方法返回的值不是基本类型，则调用<code>toString</code>方法；</li>
<li>如果<code>toString</code>方法返回的值仍不是基本类型，则抛出错误。</li>
</ol>
<p>所以<code>[] + 0</code>的执行过程如下：</p>
<ol>
<li><code>[]</code>没有<code>toPrimitive</code>方法，所以调用<code>valueOf</code>方法。</li>
<li><code>valueOf</code>方法返回值仍然是数组对象<code>[]</code>。</li>
<li>接着调用<code>toString</code>方法，返回空字符串<code>&#39;&#39;</code>。</li>
</ol>
<p>因此，<code>[] + 0</code>等价于<code>&#39;&#39; + 0</code>, 此时<code>+</code>两侧都是基本类型了，并且满足有一侧是字符串的条件，所以将另一侧的操作数<code>0</code>也转换为字符串，执行字符串连接，结果为<code>&#39;&#39; + &#39;0&#39;</code> &#x3D; <code>&#39;0&#39;</code>。</p>
<p>再来看<code>&#123;&#125; + 0</code>, <code>&#123;&#125;</code>和<code>[]</code>一样，都是对象类型，所以先将其转换为基本类型。</p>
<ol>
<li><code>&#123;&#125;</code>没有<code>toPrimitive</code>方法，所以调用<code>valueOf</code>方法，返回值仍然是对象<code>&#123;&#125;</code>。</li>
<li>接着调用<code>toString</code>方法，返回字符串<code>&#39;[object Object]&#39;</code></li>
<li>然后将<code>&#39;[object Object]&#39;</code>与<code>0</code>进行字符串连接，结果为<code>&#39;[object Object]&#39; + &#39;0&#39;</code> &#x3D; <code>&#39;[object Object]0&#39;</code>。</li>
</ol>
<p>哈哈，但是我要告诉你，这个答案是错误的，这个分析是没有问题的，但是JavaScript解释器不同意，当它看到<code>&#123;&#125;</code>时，会将其解释为一个空的代码块，而不是一个空对象，因此，<code>&#123;&#125; + 0</code>实际上等于下面的代码：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&#123;&#125;</span><br><span class="line">+ <span class="number">0</span></span><br></pre></td></tr></table></figure>
<p><code>&#123;&#125;</code>被视为一个空代码块, 没有返回任何结果，而<code>+ 0</code>被解释为一条独立的语句，返回值是0，最终结果是<code>0</code>。</p>
<p>如果要让代码按照我们上面分析的过程执行，那么就要防止JavaScript将<code>&#123;&#125;</code>解释为空代码块，可以用<code>()</code>将其包裹起来。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">(&#123;&#125;) + <span class="number">0</span> <span class="comment">// 结果为 &#x27;[object Object]0&#x27;</span></span><br></pre></td></tr></table></figure>

<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">[] + <span class="number">0</span> = <span class="string">&#x27;0&#x27;</span></span><br><span class="line">&#123;&#125; + <span class="number">0</span> = <span class="number">0</span></span><br></pre></td></tr></table></figure>
<p>说实话这道题目比较偏门，但是对于了解JavaScript中<code>+</code>运算符的行为还是很有帮助的，通过一道题，能了解一个知识点，还是很值得的。</p>
<p>有的时候，不要光纠结问题的答案，更应该关注的是问题背后的原理的规则，就比如这道题，在没有写这篇文章之前，如果让我回答，我是答不上来的，我需要查阅资料，了解<code>+</code>运算符的行为规则，才能得出正确的答案。我觉得相比知道答案，更有意思的是分析的过程，这个过程体现了一个程序员处理问题的逻辑思维能力，小到一道面试题，大到一个复杂的系统设计，都是如此。那么如何培养这种能力呢，我也一直在寻找答案…</p>
<p>最后给大家留几道思考题：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">[] + [] = ?</span><br><span class="line">&#123;&#125; + [] = ?</span><br><span class="line">[] + &#123;&#125; = ?</span><br><span class="line">&#123;&#125; + &#123;&#125; = ?</span><br></pre></td></tr></table></figure>

<p>今天就到这里了，我们明天见。</p>
<blockquote>
<p>今天周六，准备出去逛逛，奈何天气太热，动也不想动，只能呆在家里了。锁凤十代打了两天，手感非常不错，准备留下了，之前买的猛禽就退了吧，现在赚钱不易，还是要精打细算的好。</p>
</blockquote>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="en">
    <link itemprop="mainEntityOfPage" href="https://frontendthink.com/2025/07/10/typescript-type-predicate/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="Philip Zhang">
      <meta itemprop="description" content="青春都一餉，忍把浮名換了代碼輕狂。">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Philip">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2025/07/10/typescript-type-predicate/" class="post-title-link" itemprop="url">typescript-type-predicate</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>
              

              <time title="Created: 2025-07-10 19:15:44 / Modified: 22:48:29" itemprop="dateCreated datePublished" datetime="2025-07-10T19:15:44+08:00">2025-07-10</time>
            </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">In</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/typescript/" itemprop="url" rel="index"><span itemprop="name">typescript</span></a>
                </span>
            </span>

          <br>
            <span class="post-meta-item" title="Symbols count in article">
              <span class="post-meta-item-icon">
                <i class="far fa-file-word"></i>
              </span>
                <span class="post-meta-item-text">Symbols count in article: </span>
              <span>660</span>
            </span>
            <span class="post-meta-item" title="Reading time">
              <span class="post-meta-item-icon">
                <i class="far fa-clock"></i>
              </span>
                <span class="post-meta-item-text">Reading time &asymp;</span>
              <span>2 mins.</span>
            </span>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h2 id="介绍"><a href="#介绍" class="headerlink" title="介绍"></a>介绍</h2><p>各位老铁上午好，昨天我们学习了TypeScript中的类型断言(as操作符)，今天我们来学习TypeScript中的类型谓词（Type Predicate）(is操作符)。</p>
<p>为什么需要类型谓词呢？我们先看一个例子，假设我们要写一个函数，判断一个变量是否为字符串类型。</p>
<figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">isString</span>(<span class="params"><span class="attr">value</span>: <span class="built_in">unknown</span></span>): <span class="built_in">boolean</span> &#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">typeof</span> value === <span class="string">&#x27;string&#x27;</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>调用这个函数</p>
<figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">example</span>(<span class="params"><span class="attr">foo</span>: <span class="built_in">any</span></span>) &#123;</span><br><span class="line">  <span class="keyword">if</span> (<span class="title function_">isString</span>(foo)) &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(foo.<span class="title function_">toUpperCase</span>()); <span class="comment">// 这里会报错，因为foo的类型仍然是any</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="title function_">example</span>(<span class="string">&quot;hello&quot;</span>); <span class="comment">// 输出 &quot;HELLO&quot;</span></span><br><span class="line"><span class="title function_">example</span>(<span class="number">123</span>); <span class="comment">// 不会输出任何内容</span></span><br></pre></td></tr></table></figure>

<p>看起来一切正常，但是假如我们疏忽了，不小心在<code>example</code>中调用了一个不属于字符串的方法，比如<code>toFixed</code>，TypeScript会报错，因为字符串上没有<code>toFixed</code>方法。</p>
<figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">example</span>(<span class="params"><span class="attr">foo</span>: <span class="built_in">any</span></span>) &#123;</span><br><span class="line">  <span class="keyword">if</span> (<span class="title function_">isString</span>(foo)) &#123; <span class="comment">// foo的类型是any，通过检查</span></span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(foo.<span class="title function_">toFixed</span>(<span class="number">2</span>)); <span class="comment">// 编译时没有问题</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="title function_">example</span>(<span class="string">&quot;hello&quot;</span>); <span class="comment">// 运行时报错，因为字符串上没有toFixed方法</span></span><br></pre></td></tr></table></figure>

<p>在上面的代码中，虽然满足了<code>isString()</code>的判断，但是在编译期间，foo还是它本来的类型，typescript无法在编译期检查到错误。</p>
<p>但是，如果我们加上类型谓词，IDE就会提示字符串上没有<code>toFixed</code>方法。也就是说，类型谓词可以在编译时就杜绝类型错误，这就是它核心的功能。</p>
<figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">isString</span>(<span class="params"><span class="attr">value</span>: <span class="built_in">unknown</span></span>): value is <span class="built_in">string</span> &#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">typeof</span> value === <span class="string">&#x27;string&#x27;</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>上面的代码中，typescript在编译期就会将value的类型窄化为<code>string</code>，如果调用的方法不属于<code>string</code>类型，IDE会提示错误。</p>
<figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">example</span>(<span class="params"><span class="attr">foo</span>: <span class="built_in">any</span></span>) &#123;</span><br><span class="line">  <span class="keyword">if</span> (<span class="title function_">isString</span>(foo)) &#123;</span><br><span class="line">    <span class="comment">// TS2551: Property &#x27;toFixed&#x27; does not exist on type &#x27;string&#x27;.</span></span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(foo.<span class="title function_">toFixed</span>(<span class="number">2</span>)); <span class="comment">// 编译期报错</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="类型谓词的语法规则"><a href="#类型谓词的语法规则" class="headerlink" title="类型谓词的语法规则"></a>类型谓词的语法规则</h2><p>类型谓词要写在函数的返回值上，形式为：<code>value is Type</code>，其中<code>value</code>是函数的参数，<code>Type</code>是要判断的类型，比如一个判断<code>number</code>类型的函数可以这样写：</p>
<figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">isNumber</span>(<span class="params"><span class="attr">value</span>: <span class="built_in">unknown</span></span>): value is <span class="built_in">number</span> &#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">typeof</span> value === <span class="string">&#x27;number&#x27;</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="类型谓词的作用范围"><a href="#类型谓词的作用范围" class="headerlink" title="类型谓词的作用范围"></a>类型谓词的作用范围</h2><p>需要注意的是，类型谓词只在<code>isString</code>函数的作用域内有效。也就是说，只有在<code>isString</code>函数返回<code>true</code>的情况下，TypeScript才会将传入的参数类型窄化为<code>string</code>。</p>
<figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">example</span>(<span class="params"><span class="attr">foo</span>: <span class="built_in">any</span></span>) &#123;</span><br><span class="line">  <span class="keyword">if</span> (<span class="title function_">isString</span>(foo)) &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(foo.<span class="title function_">toFixed</span>()); <span class="comment">// 编译期报错，因为foo的类型被窄化为string</span></span><br><span class="line">  &#125; </span><br><span class="line"></span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(foo.<span class="title function_">toFixed</span>()); <span class="comment">// 运行时报错，因为foo的类型仍然是any</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="title function_">example</span>(<span class="string">&quot;hello&quot;</span>);</span><br></pre></td></tr></table></figure>

<p>好了，今天就到这里了，我们明天见。</p>
<blockquote>
<p>今天又买了一把新弹弓：锁凤十代，握感舒适，重量适中。理查德说这个弓可以留着，我再试两天再说。</p>
</blockquote>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="en">
    <link itemprop="mainEntityOfPage" href="https://frontendthink.com/2025/07/08/typescript-pick-optional-types/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="Philip Zhang">
      <meta itemprop="description" content="青春都一餉，忍把浮名換了代碼輕狂。">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Philip">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2025/07/08/typescript-pick-optional-types/" class="post-title-link" itemprop="url">typescript-pick-optional-types</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>

              <time title="Created: 2025-07-08 23:20:53" itemprop="dateCreated datePublished" datetime="2025-07-08T23:20:53+08:00">2025-07-08</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">Edited on</span>
                <time title="Modified: 2025-07-09 07:58:45" itemprop="dateModified" datetime="2025-07-09T07:58:45+08:00">2025-07-09</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">In</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/typescript/" itemprop="url" rel="index"><span itemprop="name">typescript</span></a>
                </span>
            </span>

          <br>
            <span class="post-meta-item" title="Symbols count in article">
              <span class="post-meta-item-icon">
                <i class="far fa-file-word"></i>
              </span>
                <span class="post-meta-item-text">Symbols count in article: </span>
              <span>1.7k</span>
            </span>
            <span class="post-meta-item" title="Reading time">
              <span class="post-meta-item-icon">
                <i class="far fa-clock"></i>
              </span>
                <span class="post-meta-item-text">Reading time &asymp;</span>
              <span>6 mins.</span>
            </span>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h2 id="什么是可选属性？"><a href="#什么是可选属性？" class="headerlink" title="什么是可选属性？"></a>什么是可选属性？</h2><p>今天我们来看一下如何从一个 TypeScript 类型中提取可选属性。那么什么是可选属性呢?<br>可选属性是指在类型定义中使用问号（<code>?</code>）标记的属性，这些属性在对象中可以存在也可以不存在。</p>
<p>以下面的<code>User</code>类型为例：其中id和name是必需的属性，而age和email是可选的属性。</p>
<figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">interface</span> <span class="title class_">User</span> &#123;</span><br><span class="line">  <span class="attr">id</span>: <span class="built_in">number</span>;</span><br><span class="line">  <span class="attr">name</span>: <span class="built_in">string</span>;</span><br><span class="line">  <span class="attr">age</span>?: <span class="built_in">number</span>; <span class="comment">// 可选属性</span></span><br><span class="line">  <span class="attr">email</span>?: <span class="built_in">string</span>; <span class="comment">// 可选属性</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>对于必须属性，我们在定义变量的时候必须提供这些属性的值。</p>
<p>下面这个变量定义是正确的，因为id和name这两个必须属性都出现了。</p>
<figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="attr">user1</span>: <span class="title class_">User</span> = &#123;</span><br><span class="line">  <span class="attr">id</span>: <span class="number">1</span>,</span><br><span class="line">  <span class="attr">name</span>: <span class="string">&#x27;Alice&#x27;</span>,</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>下面这个变量定义则是错误的，因为缺少了id属性。</p>
<figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="attr">user2</span>: <span class="title class_">User</span> = &#123;</span><br><span class="line">  <span class="attr">name</span>: <span class="string">&#x27;Philip&#x27;</span>,</span><br><span class="line">  <span class="attr">age</span>: <span class="number">18</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>TypeScript对于上面这个类型定义会给出如下错误：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">TS2741: Property &#x27;id&#x27; is missing in type &#x27;&#123; name: string; &#125;&#x27; but required in type &#x27;User&#x27;.</span><br></pre></td></tr></table></figure>

<p>对于可选属性，当它未出现在变量中时，它的值就是<code>undefined</code>（对应的类型也是<code>undefined</code>），这个特性非常重要，后面我们会用到。比如对于上面的<code>user1</code>来说，<code>user</code>.age和<code>user.email</code>的值都是<code>undefined</code>。</p>
<h2 id="可选属性的类型"><a href="#可选属性的类型" class="headerlink" title="可选属性的类型"></a>可选属性的类型</h2><p>可选属性出现时，那么它的类型就是定义的类型，比如上面的<code>age</code>属性的类型是<code>number</code>，<code>email</code>属性的类型是<code>string</code>。</p>
<p>如果可选属性未出现，那么它的类型就是<code>undefined</code>，比如上面的<code>user1</code>变量中，<code>user1.age</code>和<code>user1.email</code>的类型都是<code>undefined</code>。</p>
<p>综合下来，我们可以得出一个结论：可选属性的类型是<code>T | undefined</code>，其中<code>T</code>是可选属性的定义类型。</p>
<p>将<code>User</code>类型复制到IDE中，可以将鼠标悬停在<code>age</code>和<code>email</code>属性上，查看它们的类型。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">age 对应的类型是 number | undefined</span><br><span class="line">email 对应的类型是 string | undefined</span><br></pre></td></tr></table></figure>

<h2 id="提取可选属性"><a href="#提取可选属性" class="headerlink" title="提取可选属性"></a>提取可选属性</h2><p>可选属性介绍完毕，，现在问题来了，如何从一个类型定义中提取出所有可选属性，对应上面的<code>User</code>类型，我们需要提取出<code>age</code>和<code>email</code>这两个属性。</p>
<p>我们可以分步骤解决这个问题，每个步骤解决一个问题</p>
<h2 id="第一步：获取所有属性"><a href="#第一步：获取所有属性" class="headerlink" title="第一步：获取所有属性"></a>第一步：获取所有属性</h2><p>要提取可选属性，我们首先需要获取类型中所有的属性。TypeScript提供了内置的<code>keyof</code>操作符，可以获取一个类型的所有键（属性）。</p>
<p>假设给定的是一个类型T，那么<code>keyof T</code>将返回一个联合类型，包含T的所有属性名。</p>
<figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> <span class="title class_">UserKeys</span> = keyof <span class="title class_">User</span>; <span class="comment">// &quot;id&quot; | &quot;name&quot; | &quot;age&quot; | &quot;email&quot;</span></span><br></pre></td></tr></table></figure>
<p>假设给定的不是一个类型，而是一个变量，那么首先要用<code>typeof</code>操作符获取变量对应的的类型。再使用<code>keyof</code>获取该类型所有属性。</p>
<figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> user = &#123;</span><br><span class="line">  <span class="attr">id</span>: <span class="number">1</span>,</span><br><span class="line">  <span class="attr">name</span>: <span class="string">&#x27;Alice&#x27;</span>,</span><br><span class="line">  <span class="attr">age</span>: <span class="number">30</span>,</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> <span class="title class_">UserKeys</span> = keyof <span class="keyword">typeof</span> user; <span class="comment">// &quot;id&quot; | &quot;name&quot; | &quot;age&quot;</span></span><br></pre></td></tr></table></figure>
<p>可以看到虽然<code>user</code>变量属于<code>User</code>类型，但是两者返回的属性并不完全相同，因为<code>user</code>变量并未包含<code>email</code>属性。</p>
<h2 id="第二步：判断一个类型是否是可选的"><a href="#第二步：判断一个类型是否是可选的" class="headerlink" title="第二步：判断一个类型是否是可选的"></a>第二步：判断一个类型是否是可选的</h2><p>typescript中并没有提供内置的操作符判断一个属性是否是可选的，但是我们可以通过条件类型来实现。</p>
<p>前面说过当可选类型<code>未出现</code>时，他的值就是<code>undefined</code>(类型也是<code>undefined</code>)，所以我们可以通过判断一个属性的类型是否包含<code>undefined</code>来判断它是否是可选的。</p>
<p>下面我们来定义一个类型<code>IsOptional</code>，它接受两个参数：一个类型T和一个属性K。它将返回一个布尔值，表示属性K是否是类型T的可选属性。</p>
<p>代码大概是这个样子的</p>
<figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> <span class="title class_">IsOptional</span>&lt;T, K&gt; = <span class="literal">undefined</span> <span class="keyword">extends</span> T[K] ? <span class="literal">true</span> : <span class="literal">false</span>;</span><br></pre></td></tr></table></figure>
<p>如果K是可选的，那么T[K]的值就有可能是<code>undefined</code>，因此<code>undefined extends T[K]</code>将返回<code>true</code>，否则返回<code>false</code>。</p>
<p>举个例子：我们将T和K对应到文章开头的类型定义中，令<code>T = User</code>, 假设<code>K = age</code>，那么就有：</p>
<ul>
<li>当<code>age</code>属性存在时：<code>T[K] = number</code></li>
<li>当<code>age</code>属性不存在时：<code>T[K] = undefined</code><br>所以<code>T[K] = number | undefined</code>，因此<code>undefined extends T[K]</code>将返回<code>true</code>。</li>
</ul>
<p>假设<code>K = name</code>，因为<code>name</code>属性是必需的，所以<code>T[K] = string</code>，因此<code>undefined extends T[K]</code>将返回<code>false</code>。</p>
<p>似乎问题就要解决了，但是这里还有一个严重的问题，那就是K必须是T的属性，否则<code>T[K]</code>将会报错。所以我们还要限制一下K的值。</p>
<figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> <span class="title class_">IsOptional</span>&lt;T, K <span class="keyword">extends</span> keyof T&gt; = <span class="literal">undefined</span> <span class="keyword">extends</span> T[K] ? <span class="literal">true</span> : <span class="literal">false</span>;</span><br></pre></td></tr></table></figure>
<p><code>K extends keyof T</code>的意思是K必须是T的属性之一，这样可以避免<code>T[K]</code>报错。</p>
<h2 id="第三步：提取可选属性"><a href="#第三步：提取可选属性" class="headerlink" title="第三步：提取可选属性"></a>第三步：提取可选属性</h2><p>现在我们已经有了获取所有属性的类型<code>UserKeys</code>和判断一个属性是否是可选的类型<code>IsOptional</code>，接下来我们只需要把这两步结合起来即可：</p>
<ol>
<li>对于一个给定的类型T，我们首先获取其所有属性。</li>
<li>遍历步骤1中获取的所有属性，对于每个属性K，使用<code>IsOptional&lt;T, K&gt;</code>判断它是否是可选的。</li>
<li>如果是可选的，就将其包含在结果中，否则将其排除。</li>
</ol>
<p>代码如下：</p>
<figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> <span class="title class_">OptionalKeys</span>&lt;T&gt; = keyof &#123;</span><br><span class="line">  [K <span class="keyword">in</span> keyof T <span class="keyword">as</span> <span class="title class_">IsOptional</span>&lt;T, K&gt; <span class="keyword">extends</span> <span class="literal">true</span> ? K : <span class="built_in">never</span>]: <span class="built_in">any</span>;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>这段代码的核心部分在于<code>[K in keyof T as IsOptional&lt;T, K&gt; extends true ? K : never]</code> - 这一行代码对应了我们上面的三个步骤。</p>
<ul>
<li><code>keyof T</code> 获取所有属性。</li>
<li><code>K in keyof T</code>遍历所有属性。</li>
<li><code>as IsOptional&lt;T, K&gt; extends true ? K : never</code> 对于类型K，使用条件类型来判断属性K是否是可选的，如果是则保留K，否则将其排除（变为<code>never</code>）。</li>
</ul>
<p>但是最后为什么还有一个any呢？因为这是一个遍历操作，我们要把结果放到一个对象中，对象的key是我们提取的可选属性，对象的值就是<code>any</code>，<code>any</code>只是用来来占位的，即使使用其他类型也是一样的，比如<code>unknown</code>或者<code>void</code>都可以。</p>
<p>循环遍历完成后，我们得到一个对象如下：</p>
<figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  <span class="attr">age</span>?: <span class="built_in">any</span>;</span><br><span class="line">  <span class="attr">email</span>?: <span class="built_in">any</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>最后再使用使用<code>keyof</code>操作符获取这个对象的所有键，就得到了可选属性的联合类型：<code>&quot;age&quot; | &quot;email&quot;</code></p>
<figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">keyof &#123;</span><br><span class="line">  <span class="attr">age</span>?: <span class="built_in">any</span>;</span><br><span class="line">  <span class="attr">email</span>?: <span class="built_in">any</span>;</span><br><span class="line">&#125; <span class="comment">// &quot;age&quot; | &quot;email&quot;</span></span><br></pre></td></tr></table></figure>
<p>因此，最终的<code>OptionalKeys&lt;User&gt;</code>将返回<code>&quot;age&quot; | &quot;email&quot;</code>。</p>
<p>好了，今天就到这里了，感谢大家的支持！我们明天见。</p>
<blockquote>
<p>其实这篇文章是分两次写的，昨天晚上写了一半困得不行，遂作罢，今天早上又起来继续写。日更不能停啊。</p>
</blockquote>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="en">
    <link itemprop="mainEntityOfPage" href="https://frontendthink.com/2025/07/07/javascript-object-iterate/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="Philip Zhang">
      <meta itemprop="description" content="青春都一餉，忍把浮名換了代碼輕狂。">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Philip">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2025/07/07/javascript-object-iterate/" class="post-title-link" itemprop="url">javascript-object-iterate</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>
              

              <time title="Created: 2025-07-07 22:12:28 / Modified: 23:14:20" itemprop="dateCreated datePublished" datetime="2025-07-07T22:12:28+08:00">2025-07-07</time>
            </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">In</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/javascript/" itemprop="url" rel="index"><span itemprop="name">javascript</span></a>
                </span>
            </span>

          <br>
            <span class="post-meta-item" title="Symbols count in article">
              <span class="post-meta-item-icon">
                <i class="far fa-file-word"></i>
              </span>
                <span class="post-meta-item-text">Symbols count in article: </span>
              <span>1k</span>
            </span>
            <span class="post-meta-item" title="Reading time">
              <span class="post-meta-item-icon">
                <i class="far fa-clock"></i>
              </span>
                <span class="post-meta-item-text">Reading time &asymp;</span>
              <span>4 mins.</span>
            </span>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h2 id="JavaScript中如何遍历对象？"><a href="#JavaScript中如何遍历对象？" class="headerlink" title="JavaScript中如何遍历对象？"></a>JavaScript中如何遍历对象？</h2><p>今天来点稍微轻松的话题，如何在JavaScript中遍历对象，在平常的工作中，遍历对象是很常见的操作，javascript提供了多种方法来遍历对象的属性。这些方法各有特点，不同的场景需要使用不同的方法。</p>
<p>假设我们有一个<code>Person</code>对象，包含名字和年龄两个属性，下面看看有哪些方式可以遍历这个对象。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> person = &#123;</span><br><span class="line">  <span class="attr">name</span>: <span class="string">&#x27;Philip&#x27;</span>,</span><br><span class="line">  <span class="attr">age</span>: <span class="number">18</span>,</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h2 id="for…in"><a href="#for…in" class="headerlink" title="for…in"></a>for…in</h2><p>遍历对象最基本的方式就是使用<code>for...in</code>，这里需要注意区分和<code>for...of</code>的区别。</p>
<ul>
<li><code>for...in</code> - 遍历可枚举对象，比如<code>Object</code>。</li>
<li><code>for...of</code> - 遍历可迭代对象，比如<code>Array</code>。</li>
</ul>
<p>在以下代码中，<code>key</code>是每个属性的名字 - 对应<code>name</code>和<code>age</code>，而<code>person[key]</code>则是每个属性的值 - 对应<code>Philip</code>和<code>18</code>。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> (<span class="keyword">const</span> key <span class="keyword">in</span> person) &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(key, person[key]);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>输出如下：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">name Philip</span><br><span class="line">age 18</span><br></pre></td></tr></table></figure>
<p><code>for...in</code>是遍历对象最基本的方式，需要注意的是它不仅会遍历对象自身的属性，也会遍历原型链上的属性。假设我们在<code>Object.prototype</code>上添加一个属性，那么这个属性也会被遍历到。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="title class_">Object</span>.<span class="property"><span class="keyword">prototype</span></span>.<span class="property">customProperty</span> = <span class="string">&#x27;Hello World&#x27;</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">const</span> key <span class="keyword">in</span> person) &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(key, person[key]);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>输出如下：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">name Philip</span><br><span class="line">age 18</span><br><span class="line">customProperty Hello World</span><br></pre></td></tr></table></figure>
<p>如果你只想遍历对象自身的属性，可以使用<code>Object.hasOwnProperty</code>方法来过滤掉原型链上的属性。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> (<span class="keyword">const</span> key <span class="keyword">in</span> person) &#123;</span><br><span class="line">  <span class="keyword">if</span> (person.<span class="title function_">hasOwnProperty</span>(key)) &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(key, person[key]);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="使用for-of-Object-keys"><a href="#使用for-of-Object-keys" class="headerlink" title="使用for...of + Object.keys"></a>使用<code>for...of</code> + <code>Object.keys</code></h2><p><code>Object.keys</code>方法返回一个对象中所有可枚举属性的键名并放到一个数组里，配合<code>for...of</code>可以很方便地遍历对象的属性。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> (<span class="keyword">const</span> key <span class="keyword">of</span> <span class="title class_">Object</span>.<span class="title function_">keys</span>(person)) &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(key, person[key]);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="使用for-of-Object-values"><a href="#使用for-of-Object-values" class="headerlink" title="使用for...of + Object.values"></a>使用<code>for...of</code> + <code>Object.values</code></h2><p>如果你只关心对象的值，而不在key的话，那么可以使用<code>Object.values</code>方法，它返回一个包含对象所有可枚举属性值的数组。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> (<span class="keyword">const</span> value <span class="keyword">of</span> <span class="title class_">Object</span>.<span class="title function_">values</span>(person)) &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(value);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>输出如下：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Philip</span><br><span class="line">18</span><br></pre></td></tr></table></figure>

<h2 id="for-of-Object-entries"><a href="#for-of-Object-entries" class="headerlink" title="for...of + Object.entries"></a><code>for...of</code> + <code>Object.entries</code></h2><p>下面的方法使用<code>for...of</code>进行遍历，我们都知道<code>for..of</code>是用来遍历可迭代对象的，所以<code>Object.entries</code>返回的一定是一个可迭代对象 - 这里是一个二维数组，然后<code>[key, value]</code>是一个解构操作，负责解构内层一维数组中的值并输出。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> (<span class="keyword">const</span> [key, value] <span class="keyword">of</span> <span class="title class_">Object</span>.<span class="title function_">entries</span>(person)) &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(key, value);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><code>Object.entries(person)</code>输出如下，可以看作是一个键值对组成的二维数组。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[[name, <span class="string">&#x27;Philip&#x27;</span>], [age， <span class="number">18</span>]]</span><br></pre></td></tr></table></figure>
<p>使用<code>[key, value]</code>进行解构后正好得到两组数据：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">key = name, value = <span class="string">&#x27;Philip&#x27;</span> <span class="comment">// 第一组数据</span></span><br><span class="line">key = age, value = <span class="number">18</span> <span class="comment">// 第二组数据</span></span><br></pre></td></tr></table></figure>

<h2 id="Object-entries-forEach"><a href="#Object-entries-forEach" class="headerlink" title="Object.entries + forEach"></a><code>Object.entries</code> + <code>forEach</code></h2><p>一个更加函数式的写法是使用数组对象上的<code>forEach</code>方法。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="title class_">Object</span>.<span class="title function_">entries</span>(person).<span class="title function_">forEach</span>(<span class="function">(<span class="params">[key, value]</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(key, value);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>
<p><code>forEach</code>本质上和<code>for...of</code>并无区别，在使用链式操作时，这种方式可读性更好，比如和<code>filter</code>等方法串联调用时。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="title class_">Object</span>.<span class="title function_">entries</span>(person)</span><br><span class="line">  .<span class="title function_">filter</span>(<span class="function">(<span class="params">[key, value]</span>) =&gt;</span> key !== <span class="string">&#x27;age&#x27;</span>) <span class="comment">// 过滤掉 age 属性</span></span><br><span class="line">  .<span class="title function_">forEach</span>(<span class="function">(<span class="params">[key, value]</span>) =&gt;</span> <span class="variable language_">console</span>.<span class="title function_">log</span>(key));</span><br></pre></td></tr></table></figure>
<p>还有一点要注意，那就是<code>forEach</code>是无法中断的，比如不能使用<code>continue</code>或者<code>break</code>来中断循环，但是<code>for...in</code>和<code>for...of</code>则不受此限制。</p>
<h2 id="Reflect-ownKeys"><a href="#Reflect-ownKeys" class="headerlink" title="Reflect.ownKeys"></a>Reflect.ownKeys</h2><p>如果你的对象中有<code>Symbol</code>类型的属性，那么可以使用<code>Reflect.ownKeys</code>方法来获取所有属性的键名。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> person = &#123;</span><br><span class="line">  <span class="attr">name</span>: <span class="string">&#x27;Philip&#x27;</span>,</span><br><span class="line">  <span class="attr">age</span>: <span class="number">18</span>,</span><br><span class="line">  [<span class="title class_">Symbol</span>(<span class="string">&#x27;id&#x27;</span>)]: <span class="number">123</span>,</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="title class_">Reflect</span>.<span class="title function_">ownKeys</span>(person).<span class="title function_">forEach</span>(<span class="function"><span class="params">key</span> =&gt;</span> &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(key, person[key]);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>
<p>输出如下：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">name Philip</span><br><span class="line">age 18</span><br><span class="line">Symbol(id) 123</span><br></pre></td></tr></table></figure>
<p><code>Reflect.ownKeys</code>是遍历<code>Symbol</code>类型属性的唯一方法。</p>
<p>最后，如果你使用的是<code>TypeScript</code>，那么所有使用了索引操作的遍历方式（比如<code>person[key]</code>）都需要添加索引签名，否则<code>TypeScript</code>会报错，具体原因可以看这篇：</p>
<p>好了最后用表格总结一下：</p>
<table>
<thead>
<tr>
<th>方法</th>
<th>包含继承属性</th>
<th>包含Symbol</th>
<th>包含不可枚举属性</th>
<th>TypeScript支持</th>
</tr>
</thead>
<tbody><tr>
<td><code>for...in</code></td>
<td>✅</td>
<td>❌</td>
<td>❌</td>
<td>需要索引签名</td>
</tr>
<tr>
<td><code>Object.keys()</code></td>
<td>❌</td>
<td>❌</td>
<td>❌</td>
<td>✅</td>
</tr>
<tr>
<td><code>Object.values()</code></td>
<td>❌</td>
<td>❌</td>
<td>❌</td>
<td>✅</td>
</tr>
<tr>
<td><code>Object.entries()</code></td>
<td>❌</td>
<td>❌</td>
<td>❌</td>
<td>✅</td>
</tr>
<tr>
<td><code>Reflect.ownKeys()</code></td>
<td>❌</td>
<td>✅</td>
<td>✅</td>
<td>✅</td>
</tr>
</tbody></table>
<p>今天就到这里了，今天是我生日，感谢大家的支持，我们明天见！</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="en">
    <link itemprop="mainEntityOfPage" href="https://frontendthink.com/2025/07/06/typescript-index-signature/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="Philip Zhang">
      <meta itemprop="description" content="青春都一餉，忍把浮名換了代碼輕狂。">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Philip">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2025/07/06/typescript-index-signature/" class="post-title-link" itemprop="url">typescript-index-signature</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>
              

              <time title="Created: 2025-07-06 16:47:46 / Modified: 18:02:33" itemprop="dateCreated datePublished" datetime="2025-07-06T16:47:46+08:00">2025-07-06</time>
            </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">In</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/typescript/" itemprop="url" rel="index"><span itemprop="name">typescript</span></a>
                </span>
            </span>

          <br>
            <span class="post-meta-item" title="Symbols count in article">
              <span class="post-meta-item-icon">
                <i class="far fa-file-word"></i>
              </span>
                <span class="post-meta-item-text">Symbols count in article: </span>
              <span>745</span>
            </span>
            <span class="post-meta-item" title="Reading time">
              <span class="post-meta-item-icon">
                <i class="far fa-clock"></i>
              </span>
                <span class="post-meta-item-text">Reading time &asymp;</span>
              <span>3 mins.</span>
            </span>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h2 id="为什么我的对象无法添加新属性？"><a href="#为什么我的对象无法添加新属性？" class="headerlink" title="为什么我的对象无法添加新属性？"></a>为什么我的对象无法添加新属性？</h2><p>今天在网上看到一个问题，在typescript中定义了一个对象，却无法添加新属性，代码如下：</p>
<figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> obj = &#123;&#125;;</span><br><span class="line">obj.<span class="property">prop</span> = <span class="string">&#x27;value&#x27;</span>; <span class="comment">// Error: TS2339: Property prop does not exist on type &#123;&#125;</span></span><br></pre></td></tr></table></figure>
<p>乍一看到这个问题，我有点疑惑，为什么要这样写呢？我以往的习惯是，需要使用什么类型，都会提前定义好，然后使用就行了，这个类型包括哪些属性，都是提前设置好的。但是这段代码里面的<code>obj</code>是一个空对象，什么属性都没有，感觉实际应用中这种情况很少。</p>
<p>但是作为一个典型的例子研究一下，还是不错的。这个错误产生的原因是作者对于typescript中的索引签名(<code>index signature</code>)不熟悉导致的。我们来分析一下原因。</p>
<h2 id="索引签名"><a href="#索引签名" class="headerlink" title="索引签名"></a>索引签名</h2><p>typescript在解析<code>obj</code>的时候，并不知道它里面会有哪些属性，属性的key是什么类型？属性的值又是什么类型？完全不知道，所以当用户试图添加一个新属性的时候，typescript就会报错。<br>解决的办法也很简单，我们需要提前告知typescript这些关于属性的信息。这个信息就是索引签名</p>
<figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">interface</span> looseObject &#123;</span><br><span class="line">  [<span class="attr">key</span>: <span class="built_in">string</span>]: <span class="built_in">any</span>; <span class="comment">// 添加索引签名：属性名是字符串类型，属性值是任意类型</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="attr">obj</span>: looseObject = &#123;&#125;;</span><br><span class="line">obj.<span class="property">prop</span> = <span class="string">&#x27;value&#x27;</span>; <span class="comment">// OK</span></span><br></pre></td></tr></table></figure>

<h2 id="使用Record类型"><a href="#使用Record类型" class="headerlink" title="使用Record类型"></a>使用<code>Record</code>类型</h2><p>这个例子更简单的办法是使用<code>Record</code>类型，<code>Record</code>类型在定义特定类型的对象时特别有用。<code>Record&lt;string, any&gt;</code>表示一个对象类型，其属性名是字符串类型，属性值可以是任意类型。</p>
<figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="attr">obj</span>: <span class="title class_">Record</span>&lt;<span class="built_in">string</span>, <span class="built_in">any</span>&gt; = &#123;&#125;;</span><br><span class="line">obj.<span class="property">prop</span> = <span class="string">&#x27;value&#x27;</span>; <span class="comment">// OK</span></span><br></pre></td></tr></table></figure>

<h2 id="索引签名的使用场景"><a href="#索引签名的使用场景" class="headerlink" title="索引签名的使用场景"></a>索引签名的使用场景</h2><p>那么什么场景下需要使用索引签名呢？一般来说，当属性的个数不固定的时候，就需要使用索引签名了。</p>
<h3 id="统计学生成绩"><a href="#统计学生成绩" class="headerlink" title="统计学生成绩"></a>统计学生成绩</h3><p>比如要统计学生成绩，每个科目对应一个分数，不同专业的学生科目是不一样的，这时候就可以使用索引签名来定义一个对象类型。</p>
<figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">interface</span> <span class="title class_">StudentScores</span> &#123;</span><br><span class="line">  [<span class="attr">subject</span>: <span class="built_in">string</span>]: <span class="built_in">number</span>; <span class="comment">// 科目名是字符串类型，分数是数字类型</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="attr">scores</span>: <span class="title class_">StudentScores</span> = &#123;</span><br><span class="line">  <span class="attr">math</span>: <span class="number">90</span>,</span><br><span class="line">  <span class="attr">english</span>: <span class="number">85</span>,</span><br><span class="line">  <span class="attr">physics</span>: <span class="number">92</span>,</span><br><span class="line">&#125;;</span><br><span class="line">scores.<span class="property">chemistry</span> = <span class="number">88</span>; <span class="comment">// 可以添加新的科目</span></span><br></pre></td></tr></table></figure>

<h3 id="CSS-In-JS的使用"><a href="#CSS-In-JS的使用" class="headerlink" title="CSS-In-JS的使用"></a>CSS-In-JS的使用</h3><p>在CSS-In-JS的场景中，通常需要动态添加样式属性，这时候索引签名也非常有用。下面的代码定义了一个主题(Theme)，其中包括<code>color</code>和<code>spacing</code>属性，对于<code>color</code>属性，我们不可能列出所有可能的颜色名称，这时候可以使用索引签名就非常有用了。<code>spacing</code>也是同样的道理。</p>
<figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> <span class="title class_">Theme</span> = &#123;</span><br><span class="line">  <span class="attr">colors</span>: &#123;</span><br><span class="line">    [<span class="attr">colorName</span>: <span class="built_in">string</span>]: <span class="built_in">string</span>;</span><br><span class="line">  &#125;;</span><br><span class="line">  <span class="attr">spacing</span>: &#123;</span><br><span class="line">    [<span class="attr">size</span>: <span class="built_in">string</span>]: <span class="built_in">number</span>;</span><br><span class="line">  &#125;;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>今天就到这里了，祝大家编程愉快，喜欢就点个关注，我要去打弹弓了，明天见！</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="en">
    <link itemprop="mainEntityOfPage" href="https://frontendthink.com/2025/07/05/typescript-structural-typing-usecase/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="Philip Zhang">
      <meta itemprop="description" content="青春都一餉，忍把浮名換了代碼輕狂。">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Philip">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2025/07/05/typescript-structural-typing-usecase/" class="post-title-link" itemprop="url">typescript-structural-typing-usecase</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>

              <time title="Created: 2025-07-05 08:26:42" itemprop="dateCreated datePublished" datetime="2025-07-05T08:26:42+08:00">2025-07-05</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">Edited on</span>
                <time title="Modified: 2025-07-07 00:07:57" itemprop="dateModified" datetime="2025-07-07T00:07:57+08:00">2025-07-07</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">In</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/typescript/" itemprop="url" rel="index"><span itemprop="name">typescript</span></a>
                </span>
                  , 
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/typescript/type/" itemprop="url" rel="index"><span itemprop="name">type</span></a>
                </span>
            </span>

          <br>
            <span class="post-meta-item" title="Symbols count in article">
              <span class="post-meta-item-icon">
                <i class="far fa-file-word"></i>
              </span>
                <span class="post-meta-item-text">Symbols count in article: </span>
              <span>1.3k</span>
            </span>
            <span class="post-meta-item" title="Reading time">
              <span class="post-meta-item-icon">
                <i class="far fa-clock"></i>
              </span>
                <span class="post-meta-item-text">Reading time &asymp;</span>
              <span>5 mins.</span>
            </span>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h2 id="介绍"><a href="#介绍" class="headerlink" title="介绍"></a>介绍</h2><p>结构化类型是typescript类型系统的一个重要特性，如果不了解这个特性，则经常会被typescript的行为搞得一头雾水，导致我们期待的行为与实际的行为不一致。今天我们就来看两个例子。</p>
<p>不了解结构化类型的同学，可以先看看这篇：<a href="https://frontendthink.com/2025/07/04/javascript-structural-typing/">TypeScript结构化类型初探</a></p>
<h2 id="第一个例子"><a href="#第一个例子" class="headerlink" title="第一个例子"></a>第一个例子</h2><p>下面的代码定义了一个<code>Person</code>类型</p>
<figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">interface</span> <span class="title class_">Person</span> &#123;</span><br><span class="line">  <span class="attr">name</span>: <span class="built_in">string</span>;</span><br><span class="line">  <span class="attr">age</span>: <span class="built_in">number</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>然后又定义了一个函数打印这个类型的对象</p>
<figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">printPerson</span>(<span class="params"><span class="attr">person</span>: <span class="title class_">Person</span></span>) &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">`Name: <span class="subst">$&#123;person.name&#125;</span>, Age: <span class="subst">$&#123;person.age&#125;</span>`</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>按道理来说，要调用这个函数，必须传递一个<code>Person</code>类型的对象，但是你会发现，直接传一个对象进去也行。</p>
<figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="title function_">printPerson</span>(&#123; <span class="attr">name</span>: <span class="string">&quot;Alice&quot;</span>, <span class="attr">age</span>: <span class="number">30</span> &#125;);</span><br></pre></td></tr></table></figure>
<p>这段代码没有报错，为什么呢？因为typescript的结构化类型系统认为，只要传入的对象包含了<code>Person</code>类型所需的所有属性，就可以被认为是<code>Person</code>类型。你甚至可以多加一些属性，比如：</p>
<figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="title function_">printPerson</span>(&#123; <span class="attr">name</span>: <span class="string">&quot;Alice&quot;</span>, <span class="attr">age</span>: <span class="number">30</span>, <span class="attr">location</span>: <span class="string">&quot;Wonderland&quot;</span> &#125;);</span><br></pre></td></tr></table></figure>
<p>代码一样可以正常运行！</p>
<p>为什么？因为在typescript中，类型是<code>基于结构</code>的，而不是基于名称的。只要对象的结构符合要求，就可以被认为是该类型。如果一个类型A包含了类型B的所有属性，那么类型A就可以被认为是类型B。在使用类型B的地方，就可以使用类型A代替。</p>
<h2 id="第二个例子"><a href="#第二个例子" class="headerlink" title="第二个例子"></a>第二个例子</h2><p>还是以上面的<code>Person</code>类型为例，假设我们要打印<code>Person</code>对象中的所有属性，有的同学可能不假思索的写下如下代码：</p>
<figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">interface</span> <span class="title class_">Person</span> &#123;</span><br><span class="line">  <span class="attr">name</span>: <span class="built_in">string</span>;</span><br><span class="line">  <span class="attr">age</span>: <span class="built_in">number</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="attr">person</span>: <span class="title class_">Person</span> = &#123; <span class="attr">name</span>: <span class="string">&quot;Alice&quot;</span>, <span class="attr">age</span>: <span class="number">30</span> &#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">printProperties</span>(<span class="params"><span class="attr">person</span>: <span class="title class_">Person</span></span>) &#123;</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">const</span> property <span class="keyword">in</span> person) &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">`<span class="subst">$&#123;property&#125;</span>: <span class="subst">$&#123;person[property]&#125;</span>`</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="title function_">printProperties</span>(person);</span><br></pre></td></tr></table></figure>
<p>但是这段代码却报错了：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">TS7053: Element implicitly has an <span class="string">&#x27;any&#x27;</span> <span class="built_in">type</span> because expression of <span class="built_in">type</span> <span class="string">&#x27;string&#x27;</span> can<span class="string">&#x27;t be used to index type &#x27;</span>Person<span class="string">&#x27;. No index signature with a parameter of type &#x27;</span>string<span class="string">&#x27; was found on type &#x27;</span>Person<span class="string">&#x27;.</span></span><br></pre></td></tr></table></figure>
<p>当我第一次看到这个错误时，我只想撞墙，我哪里用<code>any</code>了，这不是胡扯吗？但这不是对待错误的正确态度，这种错误如果不彻底解决，那么它就会一直困扰你，只有将它彻底击败，下次再遇到时才能得心应手！</p>
<p>仔细看一下这个报错，它大概描述了两件事情：</p>
<ol>
<li><code>string</code>类型的值不能用来索引<code>Person</code>类型。</li>
<li><code>Person</code>类型没有定义索引签名。</li>
</ol>
<p>其实这两件事本质上说的是一个问题，那就是在TypeScript中，只有在类型中显式定义了索引签名，才能使用<code>string</code>类型的值来索引该类型。那么我们就给<code>Person</code>类型添加一个索引签名：</p>
<h3 id="方式一：为Person类型添加索引签名"><a href="#方式一：为Person类型添加索引签名" class="headerlink" title="方式一：为Person类型添加索引签名"></a>方式一：为<code>Person</code>类型添加索引签名</h3><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">interface</span> <span class="title class_">Person</span> &#123;</span><br><span class="line">  <span class="attr">name</span>: <span class="built_in">string</span>;</span><br><span class="line">  <span class="attr">age</span>: <span class="built_in">number</span>;</span><br><span class="line">  [<span class="attr">key</span>: <span class="built_in">string</span>]: <span class="built_in">any</span>; <span class="comment">// 索引签名</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p><code>[key: string]: any;</code> 这行代码的意思是，<code>Person</code>类型可以有任意数量的属性，属性名必须是字符串类型 (<code>[key: string]</code>)，属性值可以是任意类型(<code>any</code>)。</p>
</blockquote>
<p>现在我们再来运行<code>printProperties</code>函数，就不会报错了。</p>
<h3 id="方式二：使用keyof关键字"><a href="#方式二：使用keyof关键字" class="headerlink" title="方式二：使用keyof关键字"></a>方式二：使用<code>keyof</code>关键字</h3><p>坦白的说，为了一个遍历函数给<code>Person</code>类型添加一个索引签名有点过于冗余了，其实我们可以使用另一个方法来解决这个问题，那就是使用<code>keyof</code>关键字来获取<code>Person</code>类型的所有属性名。</p>
<figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">printProperties</span>(<span class="params"><span class="attr">person</span>: <span class="title class_">Person</span></span>) &#123;</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">const</span> property <span class="keyword">in</span> person) &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">`<span class="subst">$&#123;property&#125;</span>: <span class="subst">$&#123;person[property <span class="keyword">as</span> keyof <span class="keyword">typeof</span> person]&#125;</span>`</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>来看这一句代码<code>property as keyof typeof person</code>, 它的执行步骤是这样的：</p>
<ol>
<li>先执行<code>typeof person</code>，得到<code>Person</code>类型。</li>
<li>再执行<code>keyof Person</code>，得到<code>Person</code>类型的所有属性名的联合类型 - <code>name | age</code>。</li>
<li>最后使用<code>as</code>操作符将<code>property</code>转换为这个联合类型。</li>
</ol>
<p>这样做的好处是，<code>property</code>的类型被限制为<code>Person</code>类型的属性名，在本例中就是<code>name</code>和<code>age</code>这两个属性，绝不会超出这个范围，这样就可以安全地索引<code>person</code>对象了。</p>
<p>眼力好的同学可能已经发现了，上面这个写法可以简化一下，<code>property as keyof typeof person</code>可以简化为<code>property as keyof Person</code>，因为<code>person</code>的类型就是<code>Person</code>，所以我们可以直接使用<code>Person</code>类型来代替。这样可以节省一个<code>typeof</code>操作符的使用。</p>
<h3 id="方式三：使用Object-entries"><a href="#方式三：使用Object-entries" class="headerlink" title="方式三：使用Object.entries"></a>方式三：使用<code>Object.entries</code></h3><p>当然，我们还可以使用<code>Object.entries</code>方法来遍历对象的属性，这样就不需要担心索引签名的问题了。</p>
<figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">printProperty</span>(<span class="params"><span class="attr">person</span>: <span class="title class_">Person</span></span>) &#123;</span><br><span class="line">  <span class="title class_">Object</span>.<span class="title function_">entries</span>(person).<span class="title function_">forEach</span>(<span class="function">(<span class="params">[key, value]</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">`<span class="subst">$&#123;key&#125;</span>: <span class="subst">$&#123;value&#125;</span>`</span>);</span><br><span class="line">  &#125;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>分析一下这段代码：</p>
<ol>
<li><code>Object.entries</code>方法会返回一个二维数组，其中每个元素又是一个数组，这个数组包含了对象的属性名和属性值。以上面的<code>person</code>对象为例，<code>Object.entries(person)</code>会返回<code>[[&#39;name&#39;, &#39;Alice&#39;], [&#39;age&#39;, 30]]</code>，</li>
<li>接下来的<code>forEach</code>方法会遍历这个数组，这里使用了一个数组解构操作符<code>([key, value])</code>，将每个属性的名字赋值给key，属性的值赋值给value，</li>
<li>最后使用<code>console.log</code>打印出来。</li>
</ol>
<p>我比较喜欢方式三，简洁易懂，无需额外的操作。</p>
<p>今天就到这里了，觉得有用就点个关注吧，我们下次再见，我要去打弹弓了。</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="en">
    <link itemprop="mainEntityOfPage" href="https://frontendthink.com/2025/07/04/javascript-structural-typing/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="Philip Zhang">
      <meta itemprop="description" content="青春都一餉，忍把浮名換了代碼輕狂。">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Philip">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2025/07/04/javascript-structural-typing/" class="post-title-link" itemprop="url">javascript-structural-typing</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>

              <time title="Created: 2025-07-04 22:52:42" itemprop="dateCreated datePublished" datetime="2025-07-04T22:52:42+08:00">2025-07-04</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">Edited on</span>
                <time title="Modified: 2025-07-05 08:18:44" itemprop="dateModified" datetime="2025-07-05T08:18:44+08:00">2025-07-05</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">In</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/javascript/" itemprop="url" rel="index"><span itemprop="name">javascript</span></a>
                </span>
                  , 
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/javascript/type/" itemprop="url" rel="index"><span itemprop="name">type</span></a>
                </span>
            </span>

          <br>
            <span class="post-meta-item" title="Symbols count in article">
              <span class="post-meta-item-icon">
                <i class="far fa-file-word"></i>
              </span>
                <span class="post-meta-item-text">Symbols count in article: </span>
              <span>984</span>
            </span>
            <span class="post-meta-item" title="Reading time">
              <span class="post-meta-item-icon">
                <i class="far fa-clock"></i>
              </span>
                <span class="post-meta-item-text">Reading time &asymp;</span>
              <span>4 mins.</span>
            </span>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h2 id="啥是鸭子类型？"><a href="#啥是鸭子类型？" class="headerlink" title="啥是鸭子类型？"></a>啥是鸭子类型？</h2><p>作为一个前端程序员，想必大家都知道javascript是一个弱类型语言，如果需要类型的支持，那就需要借助typescript来实现，但是大家可曾听过这样一个说法？</p>
<blockquote>
<p>javascript属于鸭子类型</p>
</blockquote>
<p>当我第一次看到这个说法时，我不禁哈哈大笑，鸭子类型是啥？其实这不过是一个比喻而已，鸭子类型的意思是：</p>
<blockquote>
<p>如果一个动物看起来像鸭子，游起泳来像鸭子，叫起来也像鸭子，那么它大概率就是鸭子。</p>
</blockquote>
<h2 id="结构化类型"><a href="#结构化类型" class="headerlink" title="结构化类型"></a>结构化类型</h2><p>TypeScript使用<code>结构化类型（Structural Typing）</code>来实现javascript中的鸭子类型，结构化类型描述的是两个类型之间的兼容性，我们看一个具体的例子，再下结论。</p>
<p>假设你正在开发一个3D图形应用程序，这个程序最基本的功能就是绘制图形，而绘制图形最基本的数据结构就是点，我们先定义一个2D点。</p>
<figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">interface</span> <span class="title class_">Point2D</span> &#123;</span><br><span class="line">  <span class="attr">x</span>: <span class="built_in">number</span>;</span><br><span class="line">  <span class="attr">y</span>: <span class="built_in">number</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>当然，要绘制3D图形，我们还需要一个3D点。</p>
<figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">interface</span> <span class="title class_">Point3D</span> &#123;</span><br><span class="line">  <span class="attr">x</span>: <span class="built_in">number</span>;</span><br><span class="line">  <span class="attr">y</span>: <span class="built_in">number</span>;</span><br><span class="line">  <span class="attr">z</span>: <span class="built_in">number</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>现在我们可以下结论了，<code>Point3D</code>与<code>Point2D</code>是兼容的，因为<code>Point3D</code>包含了所有<code>Point2D</code>的属性。</p>
<p>所以结构化类型的定义如下：</p>
<blockquote>
<p>如果一个类型B包含了另一个类型A的所有属性，那么这两个类型是兼容的，我们可以将类型B赋值给类型A。</p>
</blockquote>
<p>需要注意的是，这种兼容性是单向的，<code>Point3D</code>可以赋值给<code>Point2D</code>，但反之不行，因为<code>Point2D</code>缺少了<code>z</code>属性。</p>
<p>其实这不难理解，假设我们要绘制一条2D线段，需要两个点来表示这条线段的起点和终点。</p>
<figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">drawLine</span>(<span class="params"><span class="attr">start</span>: <span class="title class_">Point2D</span>, <span class="attr">end</span>: <span class="title class_">Point2D</span></span>) &#123;</span><br><span class="line">  <span class="comment">// 绘制线段的逻辑</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>那么如果我们传入的是<code>Point3D</code>类型的点，程序依然可以正常工作，因为<code>Point3D</code>包含了<code>Point2D</code>的所有属性。多出来的<code>z</code>属性直接忽略，并不影响结果。</p>
<figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="attr">start</span>: <span class="title class_">Point3D</span> = &#123; <span class="attr">x</span>: <span class="number">0</span>, <span class="attr">y</span>: <span class="number">0</span>, <span class="attr">z</span>: <span class="number">0</span> &#125;;</span><br><span class="line"><span class="keyword">const</span> <span class="attr">end</span>: <span class="title class_">Point3D</span> = &#123; <span class="attr">x</span>: <span class="number">1</span>, <span class="attr">y</span>: <span class="number">1</span>, <span class="attr">z</span>: <span class="number">1</span> &#125;;</span><br><span class="line"><span class="title function_">drawLine</span>(start, end); <span class="comment">// 依然可以正常绘制线段</span></span><br></pre></td></tr></table></figure>

<p>我们甚至不需要传递一个<code>Point3D</code>类型的点，任意一个包含<code>x</code>和<code>y</code>属性的对象都可以作为参数传递给<code>drawLine</code>函数。</p>
<figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> start = &#123; <span class="attr">x</span>: <span class="number">0</span>, <span class="attr">y</span>: <span class="number">0</span> &#125;;</span><br><span class="line"><span class="keyword">const</span> end = &#123; <span class="attr">x</span>: <span class="number">1</span>, <span class="attr">y</span>: <span class="number">1</span> &#125;;</span><br><span class="line"><span class="title function_">drawLine</span>(start, end); <span class="comment">// 依然可以正常绘制线段</span></span><br></pre></td></tr></table></figure>
<p>这就是结构化类型的威力，也是JavaScript的灵活性所在。</p>
<h2 id="名义类型"><a href="#名义类型" class="headerlink" title="名义类型"></a>名义类型</h2><p>与结构化类型对应的是<code>名义类型（Nominal Typing）</code>，比如<code>Java</code>和<code>C#</code>这种强类型语言，使用的都是名义类型，名义类型要求类型的名称必须匹配才能兼容。也就是说，只有当两个类型的名称完全相同或者存在继承关系时，它们才被认为是兼容的。</p>
<p>对于<code>Java</code>或者<code>C#</code>这样的强类型语言来说，上面<code>drawLine</code>的例子就不成立了，因为<code>Point2D</code>和<code>Point3D</code>是两个不同的类型，即使它们有相同的属性，也不能互相替换。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Point2D</span> &#123;</span><br><span class="line">    <span class="type">int</span> x;</span><br><span class="line">    <span class="type">int</span> y;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Point3D</span> &#123;</span><br><span class="line">    <span class="type">int</span> x;</span><br><span class="line">    <span class="type">int</span> y;</span><br><span class="line">    <span class="type">int</span> z;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">void</span> <span class="title function_">drawLine</span><span class="params">(Point2D start, Point2D end)</span> &#123;</span><br><span class="line">    <span class="comment">// 绘制线段的逻辑</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">Point3D</span> <span class="variable">start</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Point3D</span>(); <span class="comment">// 定义起点</span></span><br><span class="line"><span class="type">Point3D</span> <span class="variable">end</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Point3D</span>(); <span class="comment">// 定义终点</span></span><br><span class="line">drawLine(start, end); <span class="comment">// 编译错误，Point3D不是Point2D类型</span></span><br></pre></td></tr></table></figure>

<p>基于这个原因，在强类型语言中如果要实现类型兼容性的话，只能通过继承来实现。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Point2D</span> &#123;</span><br><span class="line">    <span class="type">int</span> x;</span><br><span class="line">    <span class="type">int</span> y;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Point3D</span> <span class="keyword">extends</span> <span class="title class_">Point2D</span> &#123;</span><br><span class="line">    <span class="type">int</span> z;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">void</span> <span class="title function_">drawLine</span><span class="params">(Point2D start, Point2D end)</span> &#123;</span><br><span class="line">    <span class="comment">// 绘制线段的逻辑</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">Point3D</span> <span class="variable">start</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Point3D</span>(); <span class="comment">// 定义起点</span></span><br><span class="line"><span class="type">Point3D</span> <span class="variable">end</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Point3D</span>(); <span class="comment">// 定义终点</span></span><br><span class="line">drawLine(start, end); <span class="comment">// 现在可以正常工作</span></span><br></pre></td></tr></table></figure>

<p>上面的例子中，<code>Point3D</code>继承自<code>Point2D</code>，这就意味着<code>Point3D</code>是一个<code>Point2D</code>类型的对象，可以在需要<code>Point2D</code>的地方使用。</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="en">
    <link itemprop="mainEntityOfPage" href="https://frontendthink.com/2025/07/01/javascript-quine/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="Philip Zhang">
      <meta itemprop="description" content="青春都一餉，忍把浮名換了代碼輕狂。">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Philip">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2025/07/01/javascript-quine/" class="post-title-link" itemprop="url">javascript-quine</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>

              <time title="Created: 2025-07-01 19:47:42" itemprop="dateCreated datePublished" datetime="2025-07-01T19:47:42+08:00">2025-07-01</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">Edited on</span>
                <time title="Modified: 2025-07-08 22:17:07" itemprop="dateModified" datetime="2025-07-08T22:17:07+08:00">2025-07-08</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">In</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/javascript/" itemprop="url" rel="index"><span itemprop="name">javascript</span></a>
                </span>
            </span>

          <br>
            <span class="post-meta-item" title="Symbols count in article">
              <span class="post-meta-item-icon">
                <i class="far fa-file-word"></i>
              </span>
                <span class="post-meta-item-text">Symbols count in article: </span>
              <span>858</span>
            </span>
            <span class="post-meta-item" title="Reading time">
              <span class="post-meta-item-icon">
                <i class="far fa-clock"></i>
              </span>
                <span class="post-meta-item-text">Reading time &asymp;</span>
              <span>3 mins.</span>
            </span>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h2 id="介绍"><a href="#介绍" class="headerlink" title="介绍"></a>介绍</h2><p>如何写一段javascript程序，输出自身的源代码？这个问题非常有意思，大家不妨先尝试一下，反正在尝试了半个小时之后，我果断放弃了。</p>
<p>这种能输出自身的程序在英文里被称为<code>quine</code>。</p>
<h2 id="准备知识"><a href="#准备知识" class="headerlink" title="准备知识"></a>准备知识</h2><p>其实要实现这样一段程序，至少要掌握javascript中两个重要的知识点：</p>
<ol>
<li>IIFE</li>
<li>toString()方法</li>
</ol>
<p>关于IIFE，之前的文章已经做过详细的介绍，这里就不再赘述了，感兴趣的同学可以先去看一下。</p>
<p><a href="https://frontendthink.com/2025/06/29/javascript-iife/">JavaScript IIFE</a></p>
<p>关于<code>toString()</code>方法，相信大家也不陌生，但是你可知道对于一个函数来说，调用<code>toString()</code>方法意味着什么？</p>
<p>没错，调用一个函数的<code>toString()</code>方法会返回这个函数的源代码。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">foo</span>(<span class="params"></span>) &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;hello world&#x27;</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(foo.<span class="title function_">toString</span>()) <span class="comment">// 输出foo的源代码</span></span><br></pre></td></tr></table></figure>

<h2 id="第一个例子"><a href="#第一个例子" class="headerlink" title="第一个例子"></a>第一个例子</h2><p>有了上面的知识储备，我们可以动手写一下了，首先写一个函数<code>foo</code>，在函数体内调用<code>console.log(foo.toString())</code>输出函数的源代码。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">foo</span>(<span class="params"></span>) &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(foo.<span class="title function_">toString</span>())</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>但是这只是函数定义，并未执行，所以需要在函数定义之后调用它。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">foo</span>(<span class="params"></span>) &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(foo.<span class="title function_">toString</span>())</span><br><span class="line">&#125;</span><br><span class="line"><span class="title function_">foo</span>() <span class="comment">// 调用函数，输出源代码</span></span><br></pre></td></tr></table></figure>
<p>运行上面的代码，输出的结果如下所示，可以看到最后的调用语句<code>foo()</code>并没有打印出来。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">foo</span>(<span class="params"></span>) &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(foo.<span class="title function_">toString</span>())</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这不符合我们的要求，所以考虑去掉调用语句，将函数改为IIFE的形式</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">(<span class="keyword">function</span> <span class="title function_">foo</span>(<span class="params"></span>) &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(foo.<span class="title function_">toString</span>())</span><br><span class="line">&#125;)()</span><br></pre></td></tr></table></figure>
<p>运行上面的代码，输出的结果如下，最外层的<code>()</code>和末尾调用函数的<code>()</code>没有打印出来，这也不符合我们的要求。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">foo</span>(<span class="params"></span>) &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(foo.<span class="title function_">toString</span>())</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>改造一下内部的<code>console.log</code>，将两组括弧也输出来。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">(<span class="keyword">function</span> <span class="title function_">foo</span>(<span class="params"></span>) &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;(&#x27;</span> + foo.<span class="title function_">toString</span>() + <span class="string">&#x27;)()&#x27;</span>)</span><br><span class="line">&#125;)()</span><br></pre></td></tr></table></figure>
<p>这回结果终于正确了，我们进一步改造，使用<code>+</code>拼接字符串时，js会自动将<code>+</code>另一侧的操作数转换为字符串，所以我们可以把<code>toString()</code>省略掉。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">(<span class="keyword">function</span> <span class="title function_">foo</span>(<span class="params"></span>) &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;(&#x27;</span> + foo + <span class="string">&#x27;)()&#x27;</span>)</span><br><span class="line">&#125;)()</span><br></pre></td></tr></table></figure>

<p>再增加点神秘感，将foo换成<code>$</code></p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">(<span class="keyword">function</span> <span class="title function_">$</span>(<span class="params"></span>) &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;(&#x27;</span> + $ + <span class="string">&#x27;)()&#x27;</span>)</span><br><span class="line">&#125;)()</span><br></pre></td></tr></table></figure>
<p>运行结果如下：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">(<span class="keyword">function</span> <span class="title function_">$</span>(<span class="params"></span>) &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;(&#x27;</span> + $ + <span class="string">&#x27;)()&#x27;</span>)</span><br><span class="line">&#125;)()</span><br></pre></td></tr></table></figure>
<p>这就是一个简单的javascript quine了。</p>
<h2 id="最短的例子"><a href="#最短的例子" class="headerlink" title="最短的例子"></a>最短的例子</h2><p>在上面的例子中，为了便于观察结果，使用了<code>console.log</code>输出了源代码，实际上我们可以直接返回源代码，这样就可以省略掉<code>console.log</code>语句。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">(<span class="keyword">function</span> <span class="title function_">$</span>(<span class="params"></span>) &#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="string">&#x27;(&#x27;</span> + $ + <span class="string">&#x27;)()&#x27;</span></span><br><span class="line">&#125;)()</span><br></pre></td></tr></table></figure>

<p>根据前面两篇文章学到的<code>IIFE</code>的知识，我们使用IIFE的箭头函数形式。下面这段代码定义一个箭头函数并将其赋值给变量<code>$</code>，然后立即执行这个函数。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">($ = <span class="function">() =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="string">&#x27;(&#x27;</span> + $ + <span class="string">&#x27;)()&#x27;</span></span><br><span class="line">&#125;)()</span><br></pre></td></tr></table></figure>
<p>但是它的执行结果中没有包含<code>$</code>，我们加上<code>$</code></p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">($ = <span class="function">() =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="string">&#x27;($ =&#x27;</span> + $ + <span class="string">&#x27;)()&#x27;</span></span><br><span class="line">&#125;)()</span><br></pre></td></tr></table></figure>

<p>根据箭头函数的规则，如果返回值只有一行，那么可以省略掉大括号<code>&#123;&#125;</code>和<code>return</code>关键字，所以我们可以进一步简化为</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">($ = <span class="function">() =&gt;</span> <span class="string">&#x27;($ =&#x27;</span> + $ + <span class="string">&#x27;)()&#x27;</span>)()</span><br></pre></td></tr></table></figure>
<p>再将字符串拼接操作改为ES6的模板字符串形式：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">($ = <span class="function">() =&gt;</span> <span class="string">`($ = <span class="subst">$&#123;$&#125;</span>)()`</span>)()</span><br></pre></td></tr></table></figure>
<p>最后去掉空格，得到如下代码。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">($=<span class="function">()=&gt;</span><span class="string">`($=<span class="subst">$&#123;$&#125;</span>)()`</span>)()</span><br></pre></td></tr></table></figure>
<p>这就是史上最短的<code>javascript quine</code>了。需要注意的是，上面的代码需要在浏览器的控制台中运行，如果在IDE中运行，代码格式化工具可能会将代码格式化，导致结果不正确。</p>
<p>你还能想到其他办法吗？欢迎在评论区分享你的想法。</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  


  
  <nav class="pagination">
    <span class="page-number current">1</span><a class="page-number" href="/page/2/">2</a><span class="space">&hellip;</span><a class="page-number" href="/page/35/">35</a><a class="extend next" rel="next" href="/page/2/"><i class="fa fa-angle-right" aria-label="Next page"></i></a>
  </nav>



          </div>
          

<script>
  window.addEventListener('tabs:register', () => {
    let { activeClass } = CONFIG.comments;
    if (CONFIG.comments.storage) {
      activeClass = localStorage.getItem('comments_active') || activeClass;
    }
    if (activeClass) {
      let activeTab = document.querySelector(`a[href="#comment-${activeClass}"]`);
      if (activeTab) {
        activeTab.click();
      }
    }
  });
  if (CONFIG.comments.storage) {
    window.addEventListener('tabs:click', event => {
      if (!event.target.matches('.tabs-comment .tab-content .tab-pane')) return;
      let commentClass = event.target.classList[1];
      localStorage.setItem('comments_active', commentClass);
    });
  }
</script>

        </div>
          
  
  <div class="toggle sidebar-toggle">
    <span class="toggle-line toggle-line-first"></span>
    <span class="toggle-line toggle-line-middle"></span>
    <span class="toggle-line toggle-line-last"></span>
  </div>

  <aside class="sidebar">
    <div class="sidebar-inner">

      <ul class="sidebar-nav motion-element">
        <li class="sidebar-nav-toc">
          Table of Contents
        </li>
        <li class="sidebar-nav-overview">
          Overview
        </li>
      </ul>

      <!--noindex-->
      <div class="post-toc-wrap sidebar-panel">
      </div>
      <!--/noindex-->

      <div class="site-overview-wrap sidebar-panel">
        <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
  <p class="site-author-name" itemprop="name">Philip Zhang</p>
  <div class="site-description" itemprop="description">青春都一餉，忍把浮名換了代碼輕狂。</div>
</div>
<div class="site-state-wrap motion-element">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
          <a href="/archives/">
        
          <span class="site-state-item-count">348</span>
          <span class="site-state-item-name">posts</span>
        </a>
      </div>
      <div class="site-state-item site-state-categories">
            <a href="/categories/">
          
        <span class="site-state-item-count">44</span>
        <span class="site-state-item-name">categories</span></a>
      </div>
      <div class="site-state-item site-state-tags">
            <a href="/tags/">
          
        <span class="site-state-item-count">451</span>
        <span class="site-state-item-name">tags</span></a>
      </div>
  </nav>
</div>



      </div>

    </div>
  </aside>
  <div id="sidebar-dimmer"></div>


      </div>
    </main>

    <footer class="footer">
      <div class="footer-inner">
        

        

<div class="copyright">
  
  &copy; 
  <span itemprop="copyrightYear">2025</span>
  <span class="with-love">
    <i class="fa fa-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">Philip Zhang</span>
    <span class="post-meta-divider">|</span>
    <span class="post-meta-item-icon">
      <i class="fa fa-chart-area"></i>
    </span>
    <span title="Symbols count total">238k</span>
    <span class="post-meta-divider">|</span>
    <span class="post-meta-item-icon">
      <i class="fa fa-coffee"></i>
    </span>
    <span title="Reading time total">14:25</span>
</div>
  <div class="powered-by">Powered by <a href="https://hexo.io/" class="theme-link" rel="noopener" target="_blank">Hexo</a> & <a href="https://theme-next.org/" class="theme-link" rel="noopener" target="_blank">NexT.Gemini</a>
  </div>

        








      </div>
    </footer>
  </div>

  
  <script src="/lib/anime.min.js"></script>
  <script src="/lib/velocity/velocity.min.js"></script>
  <script src="/lib/velocity/velocity.ui.min.js"></script>

<script src="/js/utils.js"></script>

<script src="/js/motion.js"></script>


<script src="/js/schemes/pisces.js"></script>


<script src="/js/next-boot.js"></script>




  




  
<script src="/js/local-search.js"></script>













  

  

  <!-- Google tag (gtag.js) -->
<script async src="https://www.googletagmanager.com/gtag/js?id=G-MRKXK1S1GG"></script>
<script>
  window.dataLayer = window.dataLayer || [];
  function gtag(){dataLayer.push(arguments);}
  gtag('js', new Date());

  gtag('config', 'G-MRKXK1S1GG');
</script>
</body>
</html>
